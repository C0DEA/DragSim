<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Drag Racing Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 18px;
            z-index: 100;
            text-shadow: 1px 1px 2px black;
        }
        #speedometer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: none; /* Hide the original speedometer */
        }
        #distance {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        #controls {
            position: absolute;
            top: 40px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 14px;
            z-index: 100;
            text-shadow: 1px 1px 2px black;
        }
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 20px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        #startButton:hover {
            background-color: #ff7730;
        }
        #gameTitle {
            color: white;
            font-size: 40px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px black;
        }
        
        /* Restart button */
        #restartButton {
            position: absolute;
            top: 15px;
            right: 15px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 150;
            text-shadow: 1px 1px 2px black;
        }
        #restartButton:hover {
            background-color: #ff7730;
        }
        
        /* Car selection button and menu */
        #carSelectButton {
            position: absolute;
            top: 50%;
            left: 15px;
            transform: translateY(-50%);
            padding: 10px 15px;
            font-size: 16px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 150;
            text-shadow: 1px 1px 2px black;
        }
        #carSelectButton:hover {
            background-color: #ff7730;
        }
        
        #carSelectMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            z-index: 1000;
            box-sizing: border-box;
            overflow: auto;
            padding: 30px;
        }
        
        #carSelectHeader {
            text-align: center;
            margin-bottom: 40px;
            color: #ff5500;
            font-family: 'Racing Sans One', sans-serif;
        }
        
        #carSelectHeader h2 {
            font-size: 36px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }
        
        #carSelectHeader p {
            font-size: 18px;
            opacity: 0.8;
        }
        
        #carSelectGrid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 96%;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .car-option {
            background: rgba(40, 40, 40, 0.7);
            border: 2px solid #333;
            color: white;
            padding: 15px;
            cursor: pointer;
            width: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .car-option:hover {
            border-color: #ff5500;
            transform: translateY(-5px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.4);
        }
        
        .car-option h3 {
            font-size: 20px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #ff5500;
            text-align: center;
            font-family: 'Racing Sans One', sans-serif;
        }
        
        .car-model-viewer {
            width: 100%;
            height: 180px;
            margin-bottom: 15px;
            background: #1a1a1a;
            position: relative;
            border-radius: 5px;
            overflow: hidden;
        }
        
        .car-specs-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 12px;
        }
        
        .car-spec-item {
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 4px 0;
        }
        
        .car-spec-label {
            color: #aaa;
            font-size: 12px;
        }
        
        .car-spec-value {
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        
        .car-select-button {
            background: #ff5500;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            width: 100%;
            font-size: 16px;
            font-weight: bold;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
            text-transform: uppercase;
        }
        
        .car-select-button:hover {
            background: #ff7730;
        }
        
        #closeCarSelect {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            z-index: 1001;
        }
        
        #closeCarSelect:hover {
            color: #ff5500;
        }
        
        /* Gauge styles */
        #gauges {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }
        .gauge-container {
            width: 450px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border: 2px solid #444;
        }
        .gauge-background {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: linear-gradient(to bottom, #222 0%, #111 100%);
        }
        .gauge-label {
            position: absolute;
            left: 10px;
            top: 5px;
            color: white;
            font-size: 14px;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        .gauge-value {
            position: absolute;
            right: 10px;
            top: 5px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        .gauge-secondary-value {
            position: absolute;
            right: 10px;
            bottom: 5px;
            color: #aaa;
            font-size: 14px;
            text-shadow: 1px 1px 1px black;
            z-index: 10;
        }
        .gauge-bar {
            position: absolute;
            height: 15px;
            bottom: 10px;
            left: 10px;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            border-radius: 3px;
            z-index: 5;
            transition: width 0.1s ease-out;
        }
        .gauge-redline {
            position: absolute;
            width: 2px;
            height: 20px;
            bottom: 8px;
            background-color: #ff0000;
            z-index: 6;
        }
        .gauge-bar-bg {
            position: absolute;
            height: 15px;
            width: calc(100% - 20px);
            bottom: 10px;
            left: 10px;
            background-color: rgba(50, 50, 50, 0.5);
            border-radius: 3px;
            z-index: 4;
        }
        
        /* Car model display */
        #car-model {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            text-shadow: 1px 1px 2px black;
            cursor: pointer; /* Show cursor as pointer to indicate interactivity */
        }

        #car-model:hover {
            background-color: rgba(255, 85, 0, 0.3);
        }
        
        /* Car specs popup */
        #car-specs-popup {
            position: absolute;
            top: 70px;
            left: 20px;
            width: 300px;
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 8px;
            padding: 15px;
            z-index: 200;
            display: none;
            border: 2px solid #ff5500;
            box-shadow: 0 0 15px rgba(255, 85, 0, 0.6);
        }
        
        #car-specs-popup h3 {
            margin-top: 0;
            color: #ff5500;
            text-align: center;
            font-size: 20px;
            margin-bottom: 15px;
            border-bottom: 1px solid #ff5500;
            padding-bottom: 8px;
        }
        
        #car-specs-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .spec-item {
            margin-bottom: 4px;
            font-size: 14px;
        }
        
        .spec-label {
            font-weight: bold;
            color: #ff9955;
        }
        
        /* Speed gauge specific */
        #speed-gauge .gauge-background {
            background: radial-gradient(circle, #222 0%, #111 100%);
        }
        
        /* RPM gauge specific */
        #rpm-gauge .gauge-background {
            background: radial-gradient(circle, #222 0%, #111 100%);
        }
        
        /* Gear indicator */
        #gear-indicator {
            position: absolute;
            bottom: 20px;
            right: 520px; /* Changed from 320px to 520px to move it left */
            color: white;
            font-size: 36px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
            font-weight: bold;
            border: 2px solid #444;
            text-shadow: 1px 1px 2px black;
        }
        #gear-label {
            font-size: 16px;
            display: block;
            margin-bottom: 5px;
        }
        
        /* Transmission mode switch */
        #transmission-mode {
            position: absolute;
            bottom: 20px;
            right: 640px; /* Changed from 440px to 640px to move it left */
            color: white;
            font-size: 16px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
            border: 2px solid #444;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #transmission-label {
            font-size: 14px;
            margin-bottom: 5px;
            text-shadow: 1px 1px 2px black;
        }
        #transmission-toggle {
            cursor: pointer;
            display: inline-block;
            width: 60px;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            position: relative;
            transition: background-color 0.3s;
        }
        #transmission-toggle.automatic {
            background-color: #55c8ff;
        }
        #transmission-toggle.manual {
            background-color: #ff5500;
        }
        #transmission-toggle::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
            transition: left 0.3s;
        }
        #transmission-toggle.automatic::after {
            left: 33px;
        }
        #transmission-status {
            margin-top: 5px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        
        /* Quarter mile time display */
        #quarter-mile-time {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 30px;
            border-radius: 15px;
            z-index: 150;
            text-align: center;
            display: none;
            border: 3px solid #ff5500;
            text-shadow: 2px 2px 4px black;
        }
        #quarter-mile-label {
            font-size: 24px;
            display: block;
            margin-bottom: 15px;
        }
        
        #model-viewer-container {
            background-color: #222;
            border-radius: 5px;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #model-license {
            font-size: 9px;
            color: #aaa;
            line-height: 1.3;
        }
        
        #model-license p {
            margin: 5px 0;
        }
        
        #model-license a {
            color: #ff5500;
            text-decoration: none;
        }
        
        #model-license a:hover {
            text-decoration: underline;
        }
        
        .spec-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }
        
        .spec-label {
            font-weight: bold;
            color: #ff9955;
        }
        
        /* Settings Button */
        #settings-button {
            position: absolute;
            bottom: 20px;
            left: calc(50% - 60px); /* Adjusted to make space for feedback button */
            transform: translateX(-50%);
            padding: 10px 15px;
            font-size: 16px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 150;
            text-shadow: 1px 1px 2px black;
        }
        #settings-button:hover {
            background-color: #ff7730;
        }
        
        /* Feedback Button */
        #feedback-button {
            position: absolute;
            bottom: 20px;
            left: calc(50% + 60px); /* Positioned to the right of settings button */
            transform: translateX(-50%);
            padding: 10px 15px;
            font-size: 16px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 150;
            text-shadow: 1px 1px 2px black;
        }
        #feedback-button:hover {
            background-color: #ff7730;
        }
        
        /* Settings Popup */
        #settings-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            background-color: rgba(20, 20, 20, 0.9);
            border: 2px solid #ff5500;
            border-radius: 10px;
            padding: 20px;
            z-index: 1000;
            display: none;
            color: white;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .settings-header h2 {
            margin: 0;
            color: #ff5500;
        }
        
        .close-settings {
            font-size: 24px;
            cursor: pointer;
            color: #ccc;
        }
        
        .close-settings:hover {
            color: white;
        }
        
        .setting-item {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .setting-label {
            font-size: 16px;
        }
        
        .setting-control select {
            padding: 5px 10px;
            background-color: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            font-size: 14px;
        }
        
        #apply-settings {
            display: block;
            width: 100%;
            padding: 10px;
            background-color: #ff5500;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        
        #apply-settings:hover {
            background-color: #ff7730;
        }
    </style>
</head>
<body>
    <div id="debugOverlay" style="position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 10px; font-family: monospace; max-width: 80%; max-height: 30%; overflow: auto; z-index: 9999; display: none;">
        <h3>Debug Console</h3>
        <div id="debugOutput"></div>
    </div>

    <script>
        // Create a visible debug console
        const debugOverlay = document.getElementById('debugOverlay');
        const debugOutput = document.getElementById('debugOutput');
        
        // Show the debug overlay
        debugOverlay.style.display = 'block';
        
        // Additional key tracking for debug console toggle
        let dKeyPressed = false;
        let backtickKeyPressed = false;
        let lastToggleTime = 0; // Debounce toggle
        
        // Override console methods to also output to our debug div
        const originalConsoleLog = console.log;
        const originalConsoleDebug = console.debug;
        const originalConsoleError = console.error;
        
        console.log = function() {
            const args = Array.from(arguments);
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
            addDebugMessage(message, 'log');
            originalConsoleLog.apply(console, arguments);
        };
        
        console.debug = function() {
            const args = Array.from(arguments);
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
            addDebugMessage(message, 'debug');
            originalConsoleDebug.apply(console, arguments);
        };
        
        console.error = function() {
            const args = Array.from(arguments);
            const message = args.map(arg => typeof arg === 'object' ? JSON.stringify(arg) : arg).join(' ');
            addDebugMessage(message, 'error');
            originalConsoleError.apply(console, arguments);
        };
        
        function addDebugMessage(message, type) {
            const line = document.createElement('div');
            line.textContent = `[${type}] ${message}`;
            if (type === 'error') {
                line.style.color = '#ff4444';
                line.style.fontWeight = 'bold';
            } else if (type === 'debug') {
                line.style.color = '#44ff44';
            }
            
            debugOutput.appendChild(line);
            debugOutput.scrollTop = debugOutput.scrollHeight;
            
            // Limit number of messages
            while (debugOutput.children.length > 50) {
                debugOutput.removeChild(debugOutput.firstChild);
            }
        }
        
        // Function to toggle debug console visibility
        function toggleDebugConsole() {
            if (debugOverlay.style.display === 'none') {
                debugOverlay.style.display = 'block';
                console.debug("Debug console shown");
            } else {
                debugOverlay.style.display = 'none';
                console.debug("Debug console hidden");
            }
        }
    </script>
    
    <div id="container">
        <div id="info">3D Drag Racing</div>
        <div id="controls">Controls: W to accelerate, S to brake, A/D to steer, E to shift up, Q to shift down, N for neutral</div>
        <div id="speedometer">Speed: 0 mph</div>
        <div id="distance">Distance: 0 ft</div>
        
        <!-- Car model display -->
        <div id="car-model">2024 Ford Mustang GT</div>
        
        <!-- Car specs popup -->
        <div id="car-specs-popup">
            <h3>2024 Ford Mustang GT Specs</h3>
            
            <!-- 3D model viewer container -->
            <div id="model-viewer-container" style="width: 300px; height: 200px; margin-bottom: 15px;"></div>
            
            <div id="car-specs-list">
                <!-- Car specs will be populated by JavaScript -->
            </div>
            
            <div id="model-license" style="font-size: 10px; margin-top: 15px; border-top: 1px solid #555; padding-top: 5px;">
                <p><strong>Model Credit:</strong> "Ps1 Low-poly 2024 Ford Mustang Dark Horse" by LolAndPop, licensed under CC-BY-4.0</p>
                <p><a href="https://sketchfab.com/3d-models/ps1-low-poly-2024-ford-mustang-dark-horse-d15e5daca29a4b7384b5743f1ec53bd1" style="color: #ff5500;">View on Sketchfab</a></p>
            </div>
        </div>
        
        <!-- Restart button -->
        <button id="restartButton">RESTART</button>
        
        <!-- Car selection button and menu -->
        <button id="carSelectButton">SELECT CAR</button>
        <div id="carSelectMenu">
            <button id="closeCarSelect">&times;</button>
            <div id="carSelectHeader">
                <h2>Select Your Car</h2>
                <p>Choose a high-performance vehicle for your drag race</p>
            </div>
            <div id="carSelectGrid">
                <div class="car-option" data-car="mustang">
                    <h3>2024 Ford Mustang GT</h3>
                    <div class="car-model-viewer" id="mustang-model-viewer"></div>
                    <div class="car-specs-grid">
                        <div class="car-spec-item">
                            <span class="car-spec-label">Power</span>
                            <span class="car-spec-value">480 HP</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Torque</span>
                            <span class="car-spec-value">563 Nm</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">0-60 mph</span>
                            <span class="car-spec-value">4.2 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Top Speed</span>
                            <span class="car-spec-value">250 mph</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Weight</span>
                            <span class="car-spec-value">1740 kg</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Drivetrain</span>
                            <span class="car-spec-value">RWD</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Transmission</span>
                            <span class="car-spec-value">10-Speed AT</span>
                        </div>
                    </div>
                    <button class="car-select-button" data-car="mustang">Select Mustang GT</button>
                </div>
                
                <div class="car-option" data-car="porsche">
                    <h3>Porsche 911 Turbo S</h3>
                    <div class="car-model-viewer" id="porsche-model-viewer"></div>
                    <div class="car-specs-grid">
                        <div class="car-spec-item">
                            <span class="car-spec-label">Power</span>
                            <span class="car-spec-value">650 HP</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Torque</span>
                            <span class="car-spec-value">800 Nm</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">0-60 mph</span>
                            <span class="car-spec-value">2.6 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Top Speed</span>
                            <span class="car-spec-value">330 kph</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Weight</span>
                            <span class="car-spec-value">1650 kg</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Drivetrain</span>
                            <span class="car-spec-value">AWD</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Transmission</span>
                            <span class="car-spec-value">8-Speed PDK</span>
                        </div>
                    </div>
                    <button class="car-select-button" data-car="porsche">Select 911 Turbo S</button>
                </div>
                
                <div class="car-option" data-car="revuelto">
                    <h3>Lamborghini Revuelto</h3>
                    <div class="car-model-viewer" id="revuelto-model-viewer"></div>
                    <div class="car-specs-grid">
                        <div class="car-spec-item">
                            <span class="car-spec-label">Power</span>
                            <span class="car-spec-value">1001 HP</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Torque</span>
                            <span class="car-spec-value">725 Nm</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">0-60 mph</span>
                            <span class="car-spec-value">2.5 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Top Speed</span>
                            <span class="car-spec-value">350 kph</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Weight</span>
                            <span class="car-spec-value">1772 kg</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Drivetrain</span>
                            <span class="car-spec-value">AWD</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Transmission</span>
                            <span class="car-spec-value">8-Speed DCT</span>
                        </div>
                    </div>
                    <button class="car-select-button" data-car="revuelto">Select Revuelto</button>
                </div>
                
                <div class="car-option" data-car="huracan">
                    <h3>Lamborghini Huracan STO</h3>
                    <div class="car-model-viewer" id="huracan-model-viewer"></div>
                    <div class="car-specs-grid">
                        <div class="car-spec-item">
                            <span class="car-spec-label">Power</span>
                            <span class="car-spec-value">640 HP</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Torque</span>
                            <span class="car-spec-value">565 Nm</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">0-60 mph</span>
                            <span class="car-spec-value">3.0 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Top Speed</span>
                            <span class="car-spec-value">310 kph</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Weight</span>
                            <span class="car-spec-value">1339 kg</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Drivetrain</span>
                            <span class="car-spec-value">RWD</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Transmission</span>
                            <span class="car-spec-value">7-Speed DCT</span>
                        </div>
                    </div>
                    <button class="car-select-button" data-car="huracan">Select Huracan STO</button>
                </div>
                
                <div class="car-option" data-car="patrol">
                    <h3>Nissan Patrol VTC</h3>
                    <div class="car-model-viewer" id="patrol-model-viewer"></div>
                    <div class="car-specs-grid">
                        <div class="car-spec-item">
                            <span class="car-spec-label">Power</span>
                            <span class="car-spec-value">1200 HP</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Torque</span>
                            <span class="car-spec-value">1600 Nm</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">0-60 mph</span>
                            <span class="car-spec-value">6.5 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Top Speed</span>
                            <span class="car-spec-value">210 kph</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Weight</span>
                            <span class="car-spec-value">2800 kg</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Drivetrain</span>
                            <span class="car-spec-value">AWD</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Transmission</span>
                            <span class="car-spec-value">7-Speed AT</span>
                        </div>
                    </div>
                    <button class="car-select-button" data-car="patrol">Select Patrol</button>
                </div>
                
                <div class="car-option" data-car="dragster">
                    <h3>Top Fuel Dragster</h3>
                    <div class="car-model-viewer" id="dragster-model-viewer"></div>
                    <div class="car-specs-grid">
                        <div class="car-spec-item">
                            <span class="car-spec-label">Power</span>
                            <span class="car-spec-value">11000 HP</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Torque</span>
                            <span class="car-spec-value">8800 Nm</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">0-60 mph</span>
                            <span class="car-spec-value">0.8 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">1/4 Mile</span>
                            <span class="car-spec-value">3.7 sec</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Top Speed</span>
                            <span class="car-spec-value">530 kph</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Weight</span>
                            <span class="car-spec-value">1100 kg</span>
                        </div>
                        <div class="car-spec-item">
                            <span class="car-spec-label">Drivetrain</span>
                            <span class="car-spec-value">RWD</span>
                        </div>
                    </div>
                    <button class="car-select-button" data-car="dragster">Select Dragster</button>
                </div>
            </div>
        </div>
        
        <!-- Light status indicator -->
        <div id="light-status" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100%; text-align: center; color: white; font-size: 45px; z-index: 100; text-shadow: 2px 2px 4px black; font-weight: bold;">WAIT FOR GREEN LIGHT!</div>
        
        <!-- Quarter mile time display -->
        <div id="quarter-mile-time">
            <span id="quarter-mile-label">QUARTER MILE TIME</span>
            <span id="quarter-mile-value">0.00s</span>
        </div>
        
        <!-- Gauges -->
        <div id="gauges">
            <div id="rpm-gauge" class="gauge-container">
                <div class="gauge-background"></div>
                <div class="gauge-bar-bg"></div>
                <div class="gauge-bar"></div>
                <div class="gauge-redline"></div>
                <div class="gauge-label">RPM</div>
                <div class="gauge-value">0</div>
            </div>
            <div id="speed-gauge" class="gauge-container">
                <div class="gauge-background"></div>
                <div class="gauge-bar-bg"></div>
                <div class="gauge-bar"></div>
                <div class="gauge-label">SPEED</div>
                <div class="gauge-value">0 mph</div>
                <div class="gauge-secondary-value">0 km/h</div>
            </div>
        </div>
        
        <!-- Gear indicator -->
        <div id="gear-indicator">
            <span id="gear-label">GEAR</span>
            <span id="gear-value">N</span>
        </div>
        
        <!-- Transmission mode switch -->
        <div id="transmission-mode">
            <span id="transmission-label">TRANSMISSION</span>
            <div id="transmission-toggle" class="manual"></div>
            <span id="transmission-status">MANUAL</span>
        </div>
        
        <!-- Settings Button -->
        <div id="settings-button">
            <span>Settings</span>
        </div>
        
        <!-- Feedback Button -->
        <div id="feedback-button">
            <span>Feedback & Ideas</span>
        </div>
        
        <!-- Settings Popup -->
        <div id="settings-popup">
            <div class="settings-header">
                <h2>Graphics Settings</h2>
                <span class="close-settings">&times;</span>
            </div>
            <div class="settings-content">
                <div class="setting-item">
                    <span class="setting-label">Shadow Quality:</span>
                    <div class="setting-control">
                        <select id="shadow-quality">
                            <option value="2048">Low (2048px)</option>
                            <option value="4096" selected>Medium (4096px)</option>
                            <option value="8192">High (8192px)</option>
                            <option value="10240">Ultra (10240px)</option>
                        </select>
                    </div>
                </div>
                <button id="apply-settings">Apply Changes</button>
            </div>
        </div>
        
        <div id="startScreen">
            <h1 id="gameTitle">3D DRAG RACING</h1>
            <button id="startButton">START RACING</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/GammaCorrectionShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/shaders/ColorCorrectionShader.js"></script>
    
    <!-- Custom color correction shader -->
    <script>
    THREE.ColorCorrectionShader = {
        uniforms: {
            "tDiffuse": { value: null },
            "powRGB": { value: new THREE.Vector3(1.0, 1.0, 1.0) },
            "mulRGB": { value: new THREE.Vector3(1.0, 1.0, 1.0) }
        },
        vertexShader: [
            "varying vec2 vUv;",
            "void main() {",
            "    vUv = uv;",
            "    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
            "}"
        ].join("\n"),
        fragmentShader: [
            "uniform sampler2D tDiffuse;",
            "uniform vec3 powRGB;",
            "uniform vec3 mulRGB;",
            "varying vec2 vUv;",
            "void main() {",
            "    gl_FragColor = texture2D(tDiffuse, vUv);",
            "    gl_FragColor.rgb = mulRGB * pow(gl_FragColor.rgb, powRGB);",
            "}"
        ].join("\n")
    };
    </script>
    
    <script>
        // Game variables
        let scene, camera, renderer, controls, stats;
        let car, carModel, wheelFL, wheelFR, wheelBL, wheelBR;
        let track, sky;
        let ambientLight, directionalLight;
        let carVelocity = new THREE.Vector3();
        let carPosition = { x: 0, y: -0.5, z: 5 }; // Placed below ground at y = -0.5
        let carRotation = new THREE.Euler();
        let carDirection = new THREE.Vector3();
        let startLights = [];
        let startLightColors = [];
        let timeBanner, timeDisplay, timeCanvasTexture;
        let isPlaying = false;
        let speed = 0;
        let acceleration = 0;
        let distance = 0;
        let startTime = 0;
        let finishTime = 0;
        let quarterMileTime = 0;
        let quarterMileCrossed = false;
        let steeringAngle = 0;
        let rpm = 0;
        let currentGear = 0; // 0 = Neutral, 1-6 = Gears
        let clutchEngaged = false;
        let isAutomaticTransmission = false; // Default to manual transmission
        let lastGearChangeTime = 0; // Track when the last gear change occurred
        let lastShiftInput = 0; // Track last shift input time
        let clouds = []; // Array to store cloud objects
        let revLimiterActive = false; // Track if rev limiter is active
        let revLimiterShake = 0; // Visual effect for rev limiter
        let lastFrameTime = 0; // Track last frame time for delta calculation
        // Add a momentum indicator variable
        let momentumIndicatorActive = false;
        let momentumIndicatorTimeout = null;
        
        // Light system variables
        let lightSequenceActive = false;
        let lightSequenceStartTime = 0;
        let currentLightState = 0; // 0: off, 1-3: yellow lights, 4: green light
        let lightObjects = []; // Array to store light objects
        let falseStart = false; // Track if player has false started
        let raceStarted = false; // Track if race has properly started (green light)
        let initialPosition = 0; // Store the initial position of the car
        
        // 2024 Ford Mustang GT specs - Updated with accurate specs
        const MUSTANG_SPECS = {
            maxRPM: 7150,
            idleRPM: 800,
            redlineRPM: 6800,
            maxTorque: 563, // Nm (415 lb-ft converted to Nm)
            torquePeakRPM: 4900,
            powerPeakRPM: 6500,
            maxPower: 480, // HP (base GT without active exhaust)
            // 10-speed automatic transmission gear ratios for 2024 Mustang GT
            gearRatios: [
                0,      // Neutral
                4.696,  // 1st gear
                2.985,  // 2nd gear
                2.146,  // 3rd gear
                1.769,  // 4th gear
                1.520,  // 5th gear
                1.275,  // 6th gear
                1.000,  // 7th gear
                0.854,  // 8th gear
                0.689,  // 9th gear
                0.636   // 10th gear
            ],
            finalDriveRatio: 3.55,
            wheelDiameter: 0.7, // meters
            dragCoefficient: 0.30,
            frontalArea: 2.2, // m²
            weight: 1740, // kg (approx 3,827 lbs converted)
            maxSpeed: 250, // mph (estimated)
            drivetrain: "RWD" // Added drivetrain parameter
        };
        
        // 992 Porsche 911 Turbo S specs
        const PORSCHE_SPECS = {
            maxRPM: 7200,
            idleRPM: 850,
            redlineRPM: 6800,
            maxTorque: 800, // Nm
            torquePeakRPM: 2500, // Flat torque curve from 2500-4500 RPM
            powerPeakRPM: 6500,
            maxPower: 650, // HP
            // 8-speed PDK transmission gear ratios - Updated with real specifications
            gearRatios: [
                0,      // Neutral
                4.89,   // 1st gear
                3.17,   // 2nd gear - Updated
                2.15,   // 3rd gear - Updated
                1.56,   // 4th gear - Updated
                1.18,   // 5th gear - Updated
                0.94,   // 6th gear - Updated
                0.76,   // 7th gear - Updated
                0.61    // 8th gear - Updated
            ],
            finalDriveRatio: 3.02, // Updated with correct final drive ratio
            wheelDiameter: 0.65, // meters
            dragCoefficient: 0.27, // Better aerodynamics than Mustang
            frontalArea: 2.1, // m²
            weight: 1650, // kg
            maxSpeed: 330, // kph
            drivetrain: "AWD" // Added drivetrain parameter
        };
        
        // Lamborghini Revuelto specs
        const REVUELTO_SPECS = {
            maxRPM: 9500,
            idleRPM: 850,
            redlineRPM: 9000,
            maxTorque: 725, // Nm
            torquePeakRPM: 6750,
            powerPeakRPM: 9000,
            maxPower: 1001, // HP (combined hybrid system)
            // 8-speed dual-clutch transmission gear ratios
            gearRatios: [
                0,      // Neutral
                3.730,  // 1st gear
                2.381,  // 2nd gear
                1.761,  // 3rd gear
                1.368,  // 4th gear
                1.085,  // 5th gear
                0.872,  // 6th gear
                0.700,  // 7th gear
                0.514   // 8th gear
            ],
            finalDriveRatio: 3.91,
            wheelDiameter: 0.73, // meters
            dragCoefficient: 0.36,
            frontalArea: 2.1, // m²
            weight: 1772, // kg
            maxSpeed: 350, // kph
            zeroToSixty: 2.5, // seconds
            drivetrain: "AWD" // Added drivetrain parameter
        };
        
        // Lamborghini Huracan STO specs
        const HURACAN_SPECS = {
            maxRPM: 8500,
            idleRPM: 850,
            redlineRPM: 8000,
            maxTorque: 565, // Nm
            torquePeakRPM: 6500,
            powerPeakRPM: 8000,
            maxPower: 640, // HP
            // 7-speed dual-clutch transmission gear ratios
            gearRatios: [
                0,      // Neutral
                3.909,  // 1st gear
                2.438,  // 2nd gear
                1.810,  // 3rd gear
                1.458,  // 4th gear
                1.185,  // 5th gear
                0.967,  // 6th gear
                0.844   // 7th gear
            ],
            finalDriveRatio: 3.70,
            wheelDiameter: 0.71, // meters
            dragCoefficient: 0.35,
            frontalArea: 2.0, // m²
            weight: 1339, // kg
            maxSpeed: 310, // kph
            zeroToSixty: 3.0, // seconds
            drivetrain: "RWD" // Added drivetrain parameter
        };
        
        // Nissan Patrol VTC specs
        const PATROL_SPECS = {
            maxRPM: 6500,
            idleRPM: 750,
            redlineRPM: 6000,
            maxTorque: 1600, // Nm (updated from 560 to 1600)
            torquePeakRPM: 4000,
            powerPeakRPM: 5600,
            maxPower: 1200, // HP (updated from 400 to 1200)
            // 7-speed automatic transmission gear ratios
            gearRatios: [
                0,      // Neutral
                4.887,  // 1st gear
                3.170,  // 2nd gear
                2.027,  // 3rd gear
                1.412,  // 4th gear
                1.000,  // 5th gear
                0.864,  // 6th gear
                0.775   // 7th gear
            ],
            finalDriveRatio: 3.357,
            wheelDiameter: 0.85, // meters (large SUV wheels)
            dragCoefficient: 0.45, // Higher for SUV
            frontalArea: 3.2, // m² (larger for SUV)
            weight: 2800, // kg (heavy SUV)
            maxSpeed: 210, // kph
            zeroToSixty: 6.5, // seconds
            drivetrain: "AWD" // Added drivetrain parameter
        };
        
        // Top Fuel Dragster specs - authentic competition specifications
        const DRAGSTER_SPECS = {
            maxRPM: 9500,
            idleRPM: 950,
            redlineRPM: 8800,
            maxTorque: 8800, // Nm (approximately 6,500 lb-ft)
            torquePeakRPM: 7500,
            powerPeakRPM: 8000,
            maxPower: 11000, // HP (competition top fuel dragsters produce 10,000-11,000 HP)
            // Single gear direct drive with clutch
            gearRatios: [
                0,      // Neutral
                1.0     // Direct drive
            ],
            finalDriveRatio: 3.20,
            wheelDiameter: 0.90, // meters (large rear tires)
            dragCoefficient: 0.7, // High due to massive wing and parachute
            frontalArea: 1.8, // m² (narrow frontal area)
            weight: 1100, // kg (approximately 2,330 lbs with driver)
            maxSpeed: 530, // kph (approximately 330 mph)
            zeroToSixty: 0.8, // seconds (0-60 mph in less than 1 second)
            drivetrain: "RWD", // Rear-wheel drive
            quarterMileTime: 3.7 // seconds (typical top fuel quarter mile times)
        };
        
        // Current car specs - defaults to Mustang
        let currentCarSpecs = MUSTANG_SPECS;
        let currentCarName = "2024 Ford Mustang GT";
        
        // Track dimensions in meters (1:1 scale with real world)
        const TRACK_WIDTH = 11.25; // Reduced by 25% from 15 to 11.25 meters
        const TRACK_LENGTH = 1000; // 1000 meters - allows for proper quarter mile
        const FINISH_LINE = 402.336; // Quarter mile in meters (exactly 1/4 mile)
        const EXTENDED_TRACK_LENGTH = 1500; // Length including cooldown area after finish line
        const QUARTER_MILE = 402.336; // Exact quarter mile in meters (402.336m = 1/4 mile)
        const HALF_MILE = 804.672; // Exact half mile in meters (2 × 402.336m)
        
        // Missing physical constants
        const AIR_DENSITY = 1.225; // kg/m³ (air density at sea level)
        const GRAVITY = 9.81; // m/s² (acceleration due to gravity)
        const ROLLING_RESISTANCE_COEF = 0.015; // Rolling resistance coefficient for asphalt
        
        // Key states
        const keys = {
            'w': false,
            's': false,
            'a': false,
            'd': false,
            'q': false, // Shift down
            'e': false,  // Shift up
            'n': false  // Neutral
        };
        
        // Key press tracking to prevent held button repeat presses
        const keyPressTracking = {
            'q': false,
            'e': false,
            'n': false
        };
        
        // Add constants for car inertia simulation
        const DRIVETRAIN_INERTIA = 0.05; // Represents inertia of drivetrain (0-1)
        const CLUTCH_SLIP_FACTOR = 0.2; // Clutch slippage factor when partially engaged
        let lastClutchEngageTime = 0; // Track when clutch was last engaged
        
        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x66aaff); // More vibrant sky blue
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
            
            // Initialize camera orbit settings
            cameraOrbitAngle = 0; // Start looking from behind the car (better starting view)
            cameraDistance = 20; // Changed to 20 as requested
            cameraHeight = 4; // Reduced from 5 to match the new proportions
            
            // Set initial camera position using orbit parameters
            const initialCameraX = 0;
            const initialCameraZ = -4; // Moved closer to match reduced distance (from -5)
            camera.position.set(initialCameraX, cameraHeight, initialCameraZ);
            camera.lookAt(0, 0, 5); // Adjusted look-at point for better framing
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            renderer.physicallyCorrectLights = true; // Makes lights behave more like real world lights
            renderer.outputEncoding = THREE.sRGBEncoding; // Correct color space
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinema-quality tone mapping
            renderer.toneMappingExposure = 1.5; // Slightly increased for better color saturation
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Add post-processing for enhanced colors
            const composer = new THREE.EffectComposer(renderer);
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Add color correction for more vibrant look
            const colorCorrectionPass = new THREE.ShaderPass(THREE.ColorCorrectionShader);
            colorCorrectionPass.uniforms['powRGB'].value = new THREE.Vector3(1.1, 1.1, 1.2); // Slightly boost blue
            colorCorrectionPass.uniforms['mulRGB'].value = new THREE.Vector3(1.2, 1.2, 1.1); // Increase overall color intensity
            colorCorrectionPass.renderToScreen = true; // Make this the final pass
            composer.addPass(colorCorrectionPass);
            
            // Final gamma correction
            const gammaCorrectionPass = new THREE.ShaderPass(THREE.GammaCorrectionShader);
            composer.addPass(gammaCorrectionPass);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffeedd, 0.7); // Warm ambient light for summer afternoon
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8); // Pure white sunlight
            directionalLight.position.set(-25, 80, 25); // Further refined for better shadow alignment
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.left = -500;
            directionalLight.shadow.camera.right = 500;
            directionalLight.shadow.camera.top = 500;
            directionalLight.shadow.camera.bottom = -500;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 1000;
            directionalLight.shadow.mapSize.width = 4096; // Detailed shadows
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.bias = -0.00005; // Further reduced to minimize offset
            directionalLight.shadow.normalBias = 0.005; // Fine-tuned for better alignment
            
            // Alternative shadow projection type for more precise shadows
            directionalLight.shadow.camera.projection = THREE.OrthographicCamera;
            
            // Add light target for proper shadow direction
            directionalLight.target = new THREE.Object3D();
            scene.add(directionalLight.target);
            
            // Create a helper to visualize the light position and shadow camera (comment out in production)
            // const helper = new THREE.CameraHelper(directionalLight.shadow.camera);
            // scene.add(helper);
            
            scene.add(directionalLight);
            
            // Add subtle hemisphere light for environment lighting
            const hemiLight = new THREE.HemisphereLight(0xffeebb, 0x080820, 0.4); // Warm sky, subtle blue-ish ground
            scene.add(hemiLight);
            
            // Set car model display
            document.getElementById('car-model').textContent = currentCarName;
            
            // Initialize car specs popup
            initCarSpecsPopup();
            
            // Create track and environment
            createTrack();
            createEnvironment();
            
            // Create car
            createCar();
            
            // Initialize game state
            isPlaying = false;
            
            // Set initial position based on selected car
            if (currentCarName.includes('Porsche')) {
                carPosition = { x: -TRACK_WIDTH/4, y: -0.5, z: 6 }; // Position Porsche 1 meter further at y = -0.5
            } else {
                carPosition = { x: -TRACK_WIDTH/4, y: -0.5, z: 5 }; // Standard position for Mustang at y = -0.5
            }
            
            speed = 0;
            acceleration = 0;
            distance = 0;
            steeringAngle = 0;
            quarterMileCrossed = false;
            quarterMileTime = 0;
            rpm = currentCarSpecs.idleRPM;
            currentGear = 1; // Start in first gear
            
            // Position car at start line
            car.position.set(carPosition.x, carPosition.y, carPosition.z);
            
            // Update gear display
            updateGearDisplay();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('keydown', onKeyDown);
            window.addEventListener('keyup', onKeyUp);
            
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('transmission-toggle').addEventListener('click', toggleTransmissionMode);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            
            // Set up car selection button and menu
            document.getElementById('carSelectButton').addEventListener('click', toggleCarMenu);
            const carOptions = document.querySelectorAll('.car-option');
            carOptions.forEach(option => {
                option.addEventListener('click', selectCar);
            });
            
            // Set initial gear display to N
            document.getElementById('gear-value').textContent = 'N';
            
            // Start animation loop
            animate();
            
            console.log('Game initialized, ready to start!');
            
            // Ensure car select button is properly positioned
            const carSelectButton = document.getElementById('carSelectButton');
            if (carSelectButton) {
                carSelectButton.style.top = '50%';
                carSelectButton.style.transform = 'translateY(-50%)';
            }
        }
        
        function initCarSpecsPopup() {
            // Setup event listeners for car model display
            const carModelElement = document.getElementById('car-model');
            const carSpecsPopup = document.getElementById('car-specs-popup');
            
            // Show popup on hover
            carModelElement.addEventListener('mouseenter', () => {
                carSpecsPopup.style.display = 'block';
                
                // Populate specs if not already done
                if (document.getElementById('car-specs-list').children.length === 0) {
                    populateCarSpecs();
                } else {
                    // Make sure animation is running when popup is shown again
                    animatePopupModel();
                }
            });
            
            // Hide popup when mouse leaves
            carModelElement.addEventListener('mouseleave', () => {
                // Add a slight delay to prevent popup from disappearing immediately
                setTimeout(() => {
                    // Check if mouse is over the popup
                    const isOverPopup = isMouseOverElement(carSpecsPopup);
                    if (!isOverPopup) {
                        carSpecsPopup.style.display = 'none';
                        stopPopupAnimation();
                    }
                }, 100);
            });
            
            // Also handle mouse leave from popup itself
            carSpecsPopup.addEventListener('mouseleave', () => {
                setTimeout(() => {
                    // Check if mouse returned to the car model element
                    const isOverCarModel = isMouseOverElement(carModelElement);
                    if (!isOverCarModel) {
                carSpecsPopup.style.display = 'none';
                        stopPopupAnimation();
                    }
                }, 100);
            });
        }
        
        // Helper function to check if mouse is over an element
        function isMouseOverElement(element) {
            const rect = element.getBoundingClientRect();
            return (
                mouseX >= rect.left &&
                mouseX <= rect.right &&
                mouseY >= rect.top &&
                mouseY <= rect.bottom
            );
        }
        
        // Track mouse position
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        // Camera orbit and zoom variables
        let isDragging = false;
        let previousMouseX = 0;
        let previousMouseY = 0;
        let cameraOrbitAngle = 0;
        let cameraDistance = 20; // Changed to 20 as requested
        let cameraHeight = 4; // Reduced from 5 to match the new proportions
        
        // Add mouse event listeners for camera control
        document.addEventListener('mousedown', (e) => {
            isDragging = true;
            previousMouseX = e.clientX;
            previousMouseY = e.clientY;
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - previousMouseX;
                const deltaY = e.clientY - previousMouseY;
                
                // Update orbit angle based on horizontal mouse movement
                cameraOrbitAngle += deltaX * 0.01;
                
                // Update camera height based on vertical mouse movement
                cameraHeight = Math.max(2, Math.min(15, cameraHeight - deltaY * 0.05));
                
                previousMouseX = e.clientX;
                previousMouseY = e.clientY;
            }
        });
        
        // Add mouse wheel event for zoom
        document.addEventListener('wheel', (e) => {
            e.preventDefault(); // Prevent page scrolling
            
            // Calculate zoom amount based on delta with better sensitivity
            let zoomAmount;
            if (Math.abs(e.deltaY) < 100) {
                // For fine-grained touch pads
                zoomAmount = e.deltaY * 0.05;
            } else {
                // For regular mouse wheels (larger steps)
                zoomAmount = e.deltaY > 0 ? 2 : -2;
            }
            
            // Apply zoom with improved constraints
            // Zoom in closer for better detail, but not too far out
            cameraDistance = Math.max(2, Math.min(40, cameraDistance + zoomAmount)); // Increased max distance to 40 to match new default of 20
            
            // Immediately update camera position for responsive feel
            if (car) {
                const cameraX = carPosition.x + Math.sin(cameraOrbitAngle) * cameraDistance;
                const cameraZ = carPosition.z - Math.cos(cameraOrbitAngle) * cameraDistance;
                camera.position.set(cameraX, carPosition.y + cameraHeight, cameraZ);
                // Keep a fixed lookAt point regardless of zoom level for classic camera behavior
                camera.lookAt(carPosition.x, carPosition.y, carPosition.z);
            }
        }, { passive: false }); // Add passive: false to ensure preventDefault works
        
        function populateCarSpecs() {
            // Call the updateCarSpecsDisplay function to ensure consistency
            updateCarSpecsDisplay();
        }
        
        // Model viewer for popup
        let popupModelScene, popupModelCamera, popupModelRenderer, popupModelCar;
        let popupAnimationFrame;
        
        function initPopupModelViewer() {
            const container = document.getElementById('model-viewer-container');
            
            // Create scene
            popupModelScene = new THREE.Scene();
            popupModelScene.background = new THREE.Color(0x222222);
            
            // Create camera
            popupModelCamera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
            popupModelCamera.position.set(0, 1, 4);
            popupModelCamera.lookAt(0, 0, 0);
            
            // Create renderer
            popupModelRenderer = new THREE.WebGLRenderer({ antialias: true });
            popupModelRenderer.setSize(container.clientWidth, container.clientHeight);
            popupModelRenderer.shadowMap.enabled = true;
            popupModelRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
            popupModelRenderer.physicallyCorrectLights = true;
            popupModelRenderer.outputEncoding = THREE.sRGBEncoding;
            popupModelRenderer.toneMapping = THREE.ACESFilmicToneMapping;
            popupModelRenderer.toneMappingExposure = 1.5; // Slightly increased for better color saturation
            popupModelRenderer.domElement.id = 'popup-model-scene';
            container.appendChild(popupModelRenderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x89bbff, 0.8); // Sky-blue tinted ambient light
            popupModelScene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffcc, 2.0); // Warmer light color with intensity 2.0
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.001; // Adjusted for deeper, stronger shadows
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality on thin objects
            popupModelScene.add(directionalLight);
            
            // Add spinning platform
            const platformGeometry = new THREE.CircleGeometry(1.5, 32);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.1,
                envMapIntensity: 1.5
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.rotation.x = -Math.PI / 2; // Horizontal
            platform.position.y = -0.5;
            popupModelScene.add(platform);
            
            // Create model container group
            popupModelCar = new THREE.Group();
            popupModelScene.add(popupModelCar);
            
            // Load the appropriate car model
            updatePopupCarModel();
        }
        
        function createSimpleModelForPopup() {
            // Create a simple model as fallback
            const carBodyGeometry = new THREE.BoxGeometry(2, 0.5, 4);
            const carBodyMaterial = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
            const carBody = new THREE.Mesh(carBodyGeometry, carBodyMaterial);
            carBody.position.y = 0.5;
            popupModelCar.add(carBody);
            
            // Add wheels
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.2, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            // Front-left wheel
            const wheelFL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFL.rotation.z = Math.PI / 2;
            wheelFL.position.set(-1, 0.4, 1.2);
            popupModelCar.add(wheelFL);
            
            // Front-right wheel
            const wheelFR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFR.rotation.z = Math.PI / 2;
            wheelFR.position.set(1, 0.4, 1.2);
            popupModelCar.add(wheelFR);
            
            // Back-left wheel
            const wheelBL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelBL.rotation.z = Math.PI / 2;
            wheelBL.position.set(-1, 0.4, -1.2);
            popupModelCar.add(wheelBL);
            
            // Back-right wheel
            const wheelBR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelBR.rotation.z = Math.PI / 2;
            wheelBR.position.set(1, 0.4, -1.2);
            popupModelCar.add(wheelBR);
            
            // Start animation loop
            animatePopupModel();
        }
        
        function animatePopupModel() {
            // Cancel any existing animation frame
            if (popupAnimationFrame) {
                cancelAnimationFrame(popupAnimationFrame);
            }
            
            const animate = () => {
                popupAnimationFrame = requestAnimationFrame(animate);
                
                // Rotate the car
                if (popupModelCar) {
                    popupModelCar.rotation.y += 0.01;
                }
                
                // Render the scene
                popupModelRenderer.render(popupModelScene, popupModelCamera);
            };
            
            animate();
        }
        
        // Stop the popup animation when the popup is hidden
        function stopPopupAnimation() {
            if (popupAnimationFrame) {
                cancelAnimationFrame(popupAnimationFrame);
                popupAnimationFrame = null;
            }
        }
        
        function createTrack() {
            // Create the drag strip (main track + extension after finish line)
            const trackGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, EXTENDED_TRACK_LENGTH);
            const trackMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x111111, // Much darker, richer asphalt color
                roughness: 0.5,  // Lower roughness for better reflectivity
                metalness: 0.3   // Higher metalness for more dynamic light response
            });
            track = new THREE.Mesh(trackGeometry, trackMaterial);
            track.rotation.x = -Math.PI / 2;
            track.position.z = EXTENDED_TRACK_LENGTH / 2;
            track.receiveShadow = true;
            scene.add(track);
            
            // Add track border with Yas Marina blue lighting effect (only for race portion)
            const borderWidth = 1.5; // Reduced by 25% from 2 to 1.5
            const trackBorderGeometry = new THREE.PlaneGeometry(TRACK_WIDTH + borderWidth*2, TRACK_LENGTH + borderWidth*2);
            const trackBorderMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00a2ff, // More intense blue for Yas Marina
                emissive: 0x0066dd,
                emissiveIntensity: 0.7, // Increased glow
                roughness: 0.2, // Smoother surface for better reflectivity
                metalness: 0.3 // Added metalness for more vibrant light response
            });
            const trackBorder = new THREE.Mesh(trackBorderGeometry, trackBorderMaterial);
            trackBorder.rotation.x = -Math.PI / 2;
            trackBorder.position.set(0, -0.05, TRACK_LENGTH / 2);
            trackBorder.receiveShadow = true;
            scene.add(trackBorder);
            
            // Create a single center dividing line down the middle of the track (main race portion only)
            const centerLineGeometry = new THREE.PlaneGeometry(0.3, TRACK_LENGTH);
            const centerLineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffee00, // Brighter yellow
                emissive: 0x664400,
                emissiveIntensity: 0.3,
                roughness: 0.5,
                metalness: 0.3
            });
            const centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
            centerLine.rotation.x = -Math.PI / 2;
            centerLine.position.set(0, 0.01, TRACK_LENGTH / 2);
            centerLine.receiveShadow = true;
            scene.add(centerLine);
            
            // Create start line
            const startLineGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 1);
            const startLineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff, // Pure white
                emissive: 0xaaaaaa,
                emissiveIntensity: 0.4,
                roughness: 0.4,
                metalness: 0.6
            });
            const startLine = new THREE.Mesh(startLineGeometry, startLineMaterial);
            startLine.rotation.x = -Math.PI / 2;
            startLine.position.set(0, 0.02, 5);
            startLine.receiveShadow = true;
            scene.add(startLine);
            
            // Create the finish line after car initialization so we can use initialPosition
            createTrackMarkers();
            
            // Add distance markers
            createDistanceMarkers();
            
            // Add starting lights
            createStartingLights();
            
            // Create seating areas on both sides - reduced to just 2 blocks on each side
            createSeatingAreas();
            
            // Create guard rails
            createGuardRails();
        }
        
        // Separate function to create track markers with proper positioning
        function createTrackMarkers() {
            // Create quarter mile marker (white line)
            const quarterMileGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 1);
            const quarterMileMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.4,
                metalness: 0.5
            });
            const quarterMile = new THREE.Mesh(quarterMileGeometry, quarterMileMaterial);
            quarterMile.rotation.x = -Math.PI / 2;
            quarterMile.position.set(0, 0.02, 5 + QUARTER_MILE); // Add 5 to match car's starting z-position
            quarterMile.receiveShadow = true;
            scene.add(quarterMile);
            
            // Create half mile marker
            const halfMileGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 1);
            const halfMileMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.4,
                metalness: 0.5
            });
            const halfMile = new THREE.Mesh(halfMileGeometry, halfMileMaterial);
            halfMile.rotation.x = -Math.PI / 2;
            halfMile.position.set(0, 0.02, 5 + HALF_MILE); // Add 5 to match car's starting z-position
            halfMile.receiveShadow = true;
            scene.add(halfMile);
            
            // Create finish line
            const finishLineGeometry = new THREE.PlaneGeometry(TRACK_WIDTH, 1);
            const finishLineMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000, // Pure red
                emissive: 0xff0000, // Self-illuminating red
                emissiveIntensity: 0.5, // Strong emissive
                roughness: 0.3,
                metalness: 0.7 // More reflective
            });
            const finishLine = new THREE.Mesh(finishLineGeometry, finishLineMaterial);
            finishLine.rotation.x = -Math.PI / 2;
            finishLine.position.set(0, 0.02, 5 + FINISH_LINE); // Add 5 to match car's starting z-position
            finishLine.receiveShadow = true;
            scene.add(finishLine);
        }
        
        // Add distance markers along the track
        function createDistanceMarkers() {
            const markerFontSize = 2;
            const markerHeight = 2;
            const markerDistance = 200; // Every 200 meters
            
            for (let dist = markerDistance; dist < TRACK_LENGTH; dist += markerDistance) {
                // Left side marker
                const leftGeometry = new THREE.BoxGeometry(0.5, markerHeight, 0.5);
                const leftMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const leftMarker = new THREE.Mesh(leftGeometry, leftMaterial);
                leftMarker.position.set(-TRACK_WIDTH/2 - 5, markerHeight/2, dist);
                leftMarker.castShadow = true;
                scene.add(leftMarker);
                
                // Right side marker
                const rightGeometry = new THREE.BoxGeometry(0.5, markerHeight, 0.5);
                const rightMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const rightMarker = new THREE.Mesh(rightGeometry, rightMaterial);
                rightMarker.position.set(TRACK_WIDTH/2 + 5, markerHeight/2, dist);
                rightMarker.castShadow = true;
                scene.add(rightMarker);
            }
            
            // Add time display pole at 500m mark on the left side
            const timePoleGeometry = new THREE.CylinderGeometry(0.4, 0.5, 12, 8);
            const timePoleMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333, 
                metalness: 0.7,
                roughness: 0.3
            });
            const timePole = new THREE.Mesh(timePoleGeometry, timePoleMaterial);
            timePole.position.set(-TRACK_WIDTH/2 - 8, 6, 500.3); // Moved slightly behind (higher Z value)
            timePole.castShadow = true;
            scene.add(timePole);
            
            // Add a base for the pole
            const poleBaseGeometry = new THREE.CylinderGeometry(1.2, 1.5, 0.5, 8);
            const poleBaseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222, 
                metalness: 0.5,
                roughness: 0.5
            });
            const poleBase = new THREE.Mesh(poleBaseGeometry, poleBaseMaterial);
            poleBase.position.set(-TRACK_WIDTH/2 - 8, 0.25, 500.3); // Moved to match pole position
            poleBase.castShadow = true;
            scene.add(poleBase);
            
            // Add time banner to the pole
            const bannerGeometry = new THREE.BoxGeometry(12, 3, 0.3); // Increased from 8x2 to 12x3
            const bannerMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                roughness: 0.2,
                metalness: 0.5
            });
            timeBanner = new THREE.Mesh(bannerGeometry, bannerMaterial);
            timeBanner.position.set(-TRACK_WIDTH/2 - 8, 11, 500);
            timeBanner.rotation.y = Math.PI; // Rotate 180 degrees around Y-axis
            timeBanner.castShadow = true;
            scene.add(timeBanner);
            
            // Create digital time display texture
            timeCanvasTexture = createTimeDisplayTexture();
            const displayGeometry = new THREE.PlaneGeometry(11.6, 2.6); // Increased to match larger banner
            const displayMaterial = new THREE.MeshBasicMaterial({
                map: timeCanvasTexture,
                transparent: true
            });
            timeDisplay = new THREE.Mesh(displayGeometry, displayMaterial);
            timeDisplay.position.set(-TRACK_WIDTH/2 - 8, 11, 499.8); // Moved slightly forward
            timeDisplay.rotation.y = Math.PI; // Rotate 180 degrees around Y-axis
            scene.add(timeDisplay);
        }
        
        // Create a texture for the time display
        function createTimeDisplayTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Fill background
            context.fillStyle = 'rgba(0, 0, 0, 0)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Text setup for time display
            context.fillStyle = '#FF0000'; // Red digital display
            context.font = 'bold 100px "Courier New", monospace'; // Increased from 80px to 100px and ensuring bold
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('0.000', canvas.width / 2, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        // Update the time display texture
        function updateTimeDisplay(elapsedTime) {
            const canvas = timeCanvasTexture.image;
            const context = canvas.getContext('2d');
            
            // Clear the canvas
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            // Format time display
            let displayTime = '0.000';
            if (elapsedTime > 0) {
                displayTime = elapsedTime.toFixed(3);
            }
            
            // Text setup for time display
            context.fillStyle = '#FF0000'; // Red digital display
            context.font = 'bold 100px "Courier New", monospace'; // Increased from 80px to 100px and ensuring bold
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(displayTime, canvas.width / 2, canvas.height / 2);
            
            // Update the texture
            timeCanvasTexture.needsUpdate = true;
        }
        
        // Add starting lights (Christmas tree) for drag racing
        function createStartingLights() {
            // Create a light pole structure in the center of the track
            const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 5, 8);
            const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.7 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.set(0, 2.5, 25); // 20m away from the start line at z=5
            pole.castShadow = true;
            scene.add(pole);
            
            // Create light housing
            const housingGeometry = new THREE.BoxGeometry(3, 1.5, 0.7);
            const housingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x222222,
                metalness: 0.7 
            });
            const housing = new THREE.Mesh(housingGeometry, housingMaterial);
            housing.position.set(0, 4.2, 25);
            housing.castShadow = true;
            scene.add(housing);
            
            // Add the actual lights - red, yellow, green (traffic light style)
            const lightGeometry = new THREE.CircleGeometry(0.4, 16);
            const colors = [0xff0000, 0xffff00, 0x00ff00]; // Red, Yellow, Green
            
            // Create arrays to store light objects
            lightObjects = [];
            
            // Create the lights
            const lights = [];
            for (let i = 0; i < 3; i++) {
                const lightMaterial = new THREE.MeshStandardMaterial({ 
                    color: colors[i],
                    emissive: 0x333333, // Start with dim emissive
                    emissiveIntensity: 0.2
                });
                const light = new THREE.Mesh(lightGeometry, lightMaterial);
                // Position left to right: red, yellow, green
                light.position.set(-0.9 + i*0.9, 4.2, 24.65);
                light.rotation.x = Math.PI; // Face back toward the start line
                light.castShadow = true;
                light.userData = { 
                    active: false, 
                    color: colors[i], 
                    index: i 
                };
                scene.add(light);
                lights.push(light);
            }
            
            // Store the lights array
            lightObjects = [lights];
        }
        
        function createSeatingAreas() {
            // Create 2 seating blocks on each side, Yas Marina style
            const blockLength = TRACK_LENGTH / 4;
            
            // Position parameters for the blocks - moved one closer to starting position
            const blockPositions = [
                {side: -1, zPos: 100},                  // Left side, near starting position
                {side: -1, zPos: TRACK_LENGTH * 3 / 4}, // Left side, third quarter
                {side: 1, zPos: 100},                   // Right side, near starting position
                {side: 1, zPos: TRACK_LENGTH * 3 / 4}   // Right side, third quarter
            ];
            
            blockPositions.forEach((pos, index) => {
                // Create modern Yas Marina style grandstand
                createYasMarinaGrandstand(pos.side, pos.zPos, blockLength, index);
            });
        }
        
        function createYasMarinaGrandstand(side, zPosition, length, index) {
            // Create curvy modern base structure - 50% smaller
            const baseGeometry = new THREE.BoxGeometry(10, 6, length * 0.4); // Reduced from (20, 12, length * 0.8)
            const baseMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf0f0f0, // Light colored concrete like Yas Marina
                roughness: 0.5
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            
            // Position further away from track
            base.position.set(
                side * (TRACK_WIDTH / 2 + 20), // Reduced from 30 to 20 
                3, // Reduced from 6 to 3
                zPosition
            );
            base.castShadow = true;
            base.receiveShadow = true;
            scene.add(base);
            
            // Add the distinctive curved roof - 50% smaller
            const roofShape = new THREE.Shape();
            roofShape.moveTo(-5, 0); // Reduced from -10 to -5
            roofShape.quadraticCurveTo(0, 4, 5, 0); // Reduced from (0, 8, 10) to (0, 4, 5)
            
            const extrudeSettings = {
                steps: 1,
                depth: length * 0.4, // Reduced from length * 0.8 to length * 0.4
                bevelEnabled: false
            };
            
            const roofGeometry = new THREE.ExtrudeGeometry(roofShape, extrudeSettings);
            const roofMaterial = new THREE.MeshStandardMaterial({ 
                color: index % 2 === 0 ? 0x0077be : 0x00a9e0,  // Yas blue tones
                metalness: 0.7,
                roughness: 0.3
            });
            
            const roof = new THREE.Mesh(roofGeometry, roofMaterial);
            roof.position.set(
                side * (TRACK_WIDTH / 2 + 20), // Reduced from 30 to 20
                6, // Reduced from 12 to 6
                zPosition - (length * 0.2) // Reduced from length * 0.4 to length * 0.2
            );
            roof.rotation.y = Math.PI / 2;
            roof.castShadow = true;
            scene.add(roof);
            
            // Add blue glow lighting under roof - 50% smaller
            const lightGeometry = new THREE.BoxGeometry(9.75, 0.25, length * 0.39); // Reduced from (19.5, 0.5, length * 0.78)
            const lightMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00BFFF,
                emissive: 0x0077be,
                emissiveIntensity: 1,
                transparent: true,
                opacity: 0.7
            });
            const light = new THREE.Mesh(lightGeometry, lightMaterial);
            light.position.set(
                side * (TRACK_WIDTH / 2 + 20), // Reduced from 30 to 20
                5.9, // Reduced from 11.8 to 5.9
                zPosition
            );
            scene.add(light);
            
            // Add seats - 50% smaller
            const seatsGeometry = new THREE.BoxGeometry(9, 3.5, length * 0.375); // Reduced from (18, 7, length * 0.75)
            const seatsMaterial = new THREE.MeshStandardMaterial({ 
                color: index % 2 === 0 ? 0x333333 : 0x222222 
            });
            const seats = new THREE.Mesh(seatsGeometry, seatsMaterial);
            seats.position.set(
                side * (TRACK_WIDTH / 2 + 20), // Reduced from 30 to 20
                4, // Reduced from 8 to 4
                zPosition
            );
            seats.castShadow = true;
            seats.receiveShadow = true;
            scene.add(seats);
        }
        
        function createEnvironment() {
            // Create desert ground
            const groundGeometry = new THREE.PlaneGeometry(8000, 8000);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffa54f, // Vibrant orange-gold desert sand color
                roughness: 0.7,  // Optimized roughness for desert sand
                metalness: 0.1,  // Slight metalness for better light response
                emissive: 0x442200, // Warm emissive glow to enhance color
                emissiveIntensity: 0.2  // Medium intensity for noticeable effect
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.1;
            ground.receiveShadow = true;
            scene.add(ground);
            
            // Add palm trees around the track but not on the track
            for (let i = 0; i < 40; i++) {
                createPalmTree(i);
            }
            
            // Add some dunes in the background
            for (let i = 0; i < 30; i++) {
                const duneGeometry = new THREE.ConeGeometry(
                    30 + Math.random() * 70, 
                    20 + Math.random() * 50, 
                    5
                );
                const duneMaterial = new THREE.MeshStandardMaterial({
                    color: 0xe6c99f,
                    roughness: 1.0
                });
                const dune = new THREE.Mesh(duneGeometry, duneMaterial);
                
                const angle = Math.random() * Math.PI * 2;
                const dist = 800 + Math.random() * 1200;
                
                dune.position.set(
                    Math.cos(angle) * dist,
                    -10,
                    Math.sin(angle) * dist
                );
                dune.rotation.y = Math.random() * Math.PI;
                dune.castShadow = true;
                dune.receiveShadow = true;
                scene.add(dune);
            }
            
            // Add Ferrari World-inspired red dome in the distance
            const domeGeometry = new THREE.SphereGeometry(200, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshStandardMaterial({
                color: 0xcc0000, // Ferrari red
                roughness: 0.5,
                metalness: 0.2
            });
            const dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.set(-1500, 0, -1500);
            dome.castShadow = true;
            dome.receiveShadow = true;
            scene.add(dome);
            
            // Add modern skyscrapers in the background
            for (let i = 0; i < 12; i++) {
                const height = 150 + Math.random() * 250;
                const buildingGeometry = new THREE.BoxGeometry(50, height, 50);
                const buildingMaterial = new THREE.MeshStandardMaterial({
                    color: 0xaaeeff,
                    metalness: 0.8,
                    roughness: 0.2
                });
                const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                
                const angle = Math.PI / 12 * i + (Math.random() * 0.2);
                const dist = 2500;
                
                building.position.set(
                    Math.cos(angle) * dist,
                    height/2 - 20,
                    Math.sin(angle) * dist
                );
                building.castShadow = true;
                building.receiveShadow = true;
                scene.add(building);
            }
            
            // Create a larger blue-tinted sky dome to prevent car driving through horizon
            const skyGeometry = new THREE.SphereGeometry(6000, 32, 32);
            const skyMaterial = new THREE.MeshBasicMaterial({
                color: 0x3388ff, // Rich, more saturated blue
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
            
            // Add dynamic clouds
            createClouds();
        }
        
        function createPalmTree(index) {
            // Create a group to hold the model
            const group = new THREE.Group();
            
            // Add a debug sphere to show where the palm tree should be
            const debugGeometry = new THREE.SphereGeometry(2, 16, 16);
            const debugMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const debugSphere = new THREE.Mesh(debugGeometry, debugMaterial);
            debugSphere.position.y = 5; // Position above ground to be visible
            group.add(debugSphere);
            
            console.debug(`Creating palm tree #${index}`);
            
            // Randomly select which palm tree model to use
            // 0 = Curly_palm, 1 = Date_palm
            const palmType = Math.floor(Math.random() * 2);
            console.debug(`Selected palm type: ${palmType === 0 ? 'Curly_palm' : 'Date_palm'}`);
            
            // Model paths - use absolute paths to ensure correct loading
            const palmModels = [
                '/assets/Curly_palm/scene.gltf',  // Curly palm - absolute path from root
                '/assets/Date_palm/scene.gltf'    // Date palm - absolute path from root
            ];
            
            console.debug(`Loading palm model from path: ${palmModels[palmType]}`);
            
            // Load the selected palm tree model - ensure DRACOLoader is properly set up
            const gltfLoader = new THREE.GLTFLoader();
            const dracoLoader = new THREE.DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
            gltfLoader.setDRACOLoader(dracoLoader);
            
            // Different scale ranges for each tree type as requested
            // Curly palm: Scale between 3-6
            // Date palm: Scale between 1-2
            const scaleRanges = [
                { min: 3.0, max: 6.0 },  // Curly palm scale range
                { min: 1.0, max: 2.0 }   // Date palm scale range
            ];
            
            // Generate random scale within the appropriate range for the selected tree type
            const scaleValue = scaleRanges[palmType].min + Math.random() * (scaleRanges[palmType].max - scaleRanges[palmType].min);
            console.debug(`Generated ${palmType === 0 ? 'Curly palm' : 'Date palm'} scale: ${scaleValue.toFixed(2)}`);
            
            // Load the model
            gltfLoader.load(
                palmModels[palmType],
                function(gltf) {
                    console.debug(`Successfully loaded palm model #${index}!`);
                    
                    const palmModel = gltf.scene;
                    
                    // Apply scale and rotation adjustments
                    palmModel.scale.set(scaleValue, scaleValue, scaleValue);
                    console.debug(`Applied scale: ${scaleValue}`);
                    
                    // Random rotation for variety
                    palmModel.rotation.y = Math.random() * Math.PI * 2;
                    
                    // Keep Y position static at 0 as requested
                    palmModel.position.y = 0;
                    
                    // Remove debug sphere once model is loaded
                    group.remove(debugSphere);
                    
                    // Check for meshes in the model
                    let meshCount = 0;
                    palmModel.traverse(function(node) {
                        if (node.isMesh) {
                            meshCount++;
                            node.castShadow = true;
                            node.receiveShadow = true;
                            
                            // Log material information to check if materials are loading correctly
                            if (node.material) {
                                console.debug(`Mesh has material: ${node.material.name || 'unnamed'}`);
                            } else {
                                console.debug(`Mesh has no material`);
                            }
                        }
                    });
                    console.debug(`Palm model contains ${meshCount} meshes`);
                    
                    // Add model to group
                    group.add(palmModel);
                },
                function(xhr) {
                    // Progress callback
                    console.debug(`Palm #${index} loading progress: ${Math.round((xhr.loaded / xhr.total) * 100)}%`);
                },
                function(error) {
                    console.error(`Error loading palm tree model #${index}:`, error);
                    
                    // Create a simple fallback palm tree if loading fails
                    console.debug(`Using fallback palm tree for #${index}`);
                    createFallbackPalmTree(group);
                }
            );
            
            // Position the palm tree - keeping the same positioning logic as the original
            let x, z;
            
            if (index < 16) {
                // Line both sides of the track near the start with good clearance
                const side = index % 2 === 0 ? -1 : 1;
                const position = Math.floor(index / 2);
                x = side * (TRACK_WIDTH / 2 + 15 + Math.random() * 4); // Moved further from track
                z = 20 + position * 40 + Math.random() * 10;
            } else if (index < 24) {
                // Some near the grandstands with good clearance
                const side = index % 2 === 0 ? -1 : 1;
                x = side * (TRACK_WIDTH / 2 + 50 + Math.random() * 10); // Moved further out
                z = (index % 4 < 2) ? 100 + Math.random() * 30 : TRACK_LENGTH * 0.75 + Math.random() * 30;
            } else {
                // Rest are randomly placed around the environment, but avoid the track
                const angle = Math.random() * Math.PI * 2;
                const dist = 300 + Math.random() * 200;
                x = Math.cos(angle) * dist;
                z = Math.sin(angle) * dist;
                
                // Make sure trees don't appear on the track
                if (Math.abs(x) < TRACK_WIDTH/2 && z > 0 && z < TRACK_LENGTH) {
                    x = Math.sign(x) * (TRACK_WIDTH/2 + 10 + Math.random() * 5);
                }
            }
            
            console.debug(`Positioning palm #${index} at x:${x.toFixed(2)}, z:${z.toFixed(2)}`);
            group.position.set(x, 0, z);
            scene.add(group);
        }
        
        // Fallback function to create a simple palm tree if model loading fails
        function createFallbackPalmTree(group) {
            // Simple trunk
            const trunkGeometry = new THREE.CylinderGeometry(0.35, 0.5, 7.5, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xa05a2c,
                roughness: 0.75,
                metalness: 0.1,
                emissive: 0x3a2816,
                emissiveIntensity: 0.2
            });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 3.75;
            trunk.castShadow = true;
            group.add(trunk);
            
            // Simple fronds
            for (let i = 0; i < 7; i++) {
                const frondShape = new THREE.Shape();
                frondShape.moveTo(0, 0);
                frondShape.quadraticCurveTo(1, 0.5, 4, 0);
                frondShape.quadraticCurveTo(1, -0.5, 0, 0);
                
                const extrudeSettings = {
                    steps: 1,
                    depth: 0.1,
                    bevelEnabled: false
                };
                
                const frondGeometry = new THREE.ExtrudeGeometry(frondShape, extrudeSettings);
                const frondMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x00aa00,
                    roughness: 0.8,
                    metalness: 0.1,
                    emissive: 0x003300,
                    emissiveIntensity: 0.15
                });
                const frond = new THREE.Mesh(frondGeometry, frondMaterial);
                frond.position.set(0, 7.5, 0);
                frond.rotation.set(
                    Math.random() * 0.5 - 0.25,
                    (Math.PI * 2 / 7) * i,
                    Math.random() * 0.2 + 0.3
                );
                frond.castShadow = true;
                group.add(frond);
            }
        }
        
        function createCar() {
            console.debug('Creating car...');
            
            // Create a container group for the car
            car = new THREE.Group();
            scene.add(car);
            
            // Set car position
            car.position.set(0, 0.5, 5);
            
            // Important message about local file access
            console.debug('⚠️ IMPORTANT: Loading 3D models directly from the file system might fail due to browser security restrictions.');
            console.debug('Best solution: Run this HTML file using a local web server instead of opening it directly.');
            console.debug('Simple option: Use VS Code with Live Server extension, or Python simple server: python -m http.server');
            
            // Try to load the appropriate car model
            console.debug('Setting up enhanced model loaders');
            
            // Create and configure GLTF loader with DRACO support
            const gltfLoader = new THREE.GLTFLoader();
            
            // Try to set up DRACO loader if available
            try {
                if (typeof THREE.DRACOLoader !== 'undefined') {
                    const dracoLoader = new THREE.DRACOLoader();
                    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
                    gltfLoader.setDRACOLoader(dracoLoader);
                    console.debug('DRACO loader configured successfully');
                }
            } catch (e) {
                console.debug('DRACO loader not available:', e);
            }
            
            // Select the appropriate model based on the car type
            let modelFolder;
            let fileExtension;
            let pathsToTry;
            
            if (currentCarName.includes('Porsche')) {
                modelFolder = 'Porsche911TurboS';
            } else if (currentCarName.includes('Revuelto')) {
                modelFolder = 'Revuelto';
            } else if (currentCarName.includes('Huracan')) {
                modelFolder = 'HuracanSTO';
            } else if (currentCarName.includes('Patrol')) {
                modelFolder = 'NissanPatrolVTC';
            } else if (currentCarName.includes('Dragster')) {
                modelFolder = 'Dragster';
                console.warn('DRAGSTER SELECTED - Will try to load from folder:', modelFolder);
            } else {
                modelFolder = 'FordMustang';
            }
            
            fileExtension = 'scene.gltf';
            pathsToTry = [
                `${modelFolder}/${fileExtension}`,
                `./${modelFolder}/${fileExtension}`,
                `../${modelFolder}/${fileExtension}`,
                `../../${modelFolder}/${fileExtension}`,
                window.location.href.substr(0, window.location.href.lastIndexOf('/') + 1) + `${modelFolder}/${fileExtension}`
            ];
            
            console.debug(`Will try these paths directly for ${currentCarName}:`, pathsToTry);
            
            // Try loading using XMLHttpRequest first as a diagnostic step
            const xhr = new XMLHttpRequest();
            xhr.open('GET', `${modelFolder}/${fileExtension}`, true);
            xhr.onload = function() {
                if (xhr.status === 200) {
                    console.debug('✅ File is accessible via XMLHttpRequest!');
                    try {
                        const parsedContent = JSON.parse(xhr.responseText);
                        console.debug('✅ File is valid JSON with these keys:', Object.keys(parsedContent));
                        
                        // The file exists and is valid JSON, proceed with normal loading
                        tryNextPath(0);
                    } catch (e) {
                        console.error('❌ File exists but is not valid JSON:', e);
                        tryAlternativeLoading();
                    }
                } else {
                    console.error(`❌ File not accessible via XMLHttpRequest, status: ${xhr.status}`);
                    tryNextPath(0);
                }
            };
            xhr.onerror = function() {
                console.error('❌ XMLHttpRequest failed completely');
                tryNextPath(0);
            };
            
            // Send the request
            try {
                xhr.send();
            } catch (e) {
                console.error('❌ XMLHttpRequest send error:', e);
                tryNextPath(0);
            }
            
            // Function to try loading from each path in sequence
            function tryNextPath(index) {
                if (index >= pathsToTry.length) {
                    console.error('All standard paths failed, trying alternative loading approach');
                    tryAlternativeLoading();
                    return;
                }
                
                const currentPath = pathsToTry[index];
                console.debug(`Attempting to load model directly from path ${index+1}/${pathsToTry.length}: ${currentPath}`);
                
                // Try loading directly with GLTFLoader
                gltfLoader.load(
                    currentPath,
                    function(gltf) {
                        console.debug('✅ Model loaded successfully!');
                        
                        carModel = gltf.scene;
                        
                        // Apply transformations based on car type
                        if (currentCarName.includes('Porsche')) {
                            // Porsche-specific transformations
                            carModel.scale.set(0.5, 0.5, 0.5);  // Changed from 0.75 to 0.5 as requested
                            carModel.rotation.y = Math.PI * 1.5;   // Rotate 270 degrees
                            carModel.position.y = 0.65;            // Changed from 0.8 to 0.65 as requested
                            carModel.position.x = 0.6;             // Move 0.1 more to the right
                            carModel.position.z = 1.0;             // Move 1 meter forward
                        } else if (currentCarName.includes('Revuelto')) {
                            // Lamborghini Revuelto transformations
                            carModel.scale.set(100, 100, 100);     // Scale set to 100 as requested
                            carModel.rotation.y = Math.PI * 2;     // Full 360 degree rotation
                            
                            // Apply additional 180-degree rotation separately to be explicit
                            carModel.rotateY(Math.PI);             // Add 180 degrees rotation
                            
                            carModel.position.y = 0.5;             // Lower height position as requested
                            carModel.position.x = 0;               // Centered
                            carModel.position.z = 1.0;             // Move 1 meter forward
                        } else if (currentCarName.includes('Huracan')) {
                            // Lamborghini Huracan transformations
                            carModel.scale.set(100, 100, 100);        // Changed from 180 to 100 as requested
                            carModel.rotation.y = 0;               // Changed to 0 (previously was backward)
                            carModel.position.y = 0.5;             // Lowered from 0.65 to 0.5 as requested
                            carModel.position.x = 0;               // Centered
                            carModel.position.z = 1.0;             // Move 1 meter forward
                            
                            // Fix wheel rotation axes for proper spinning
                            carModel.traverse(function(node) {
                                if (node.isMesh) {
                                    const name = node.name.toLowerCase();
                                    if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) {
                                        // Store original rotation axis for wheel spinning
                                        node.userData.isWheel = true;
                                        node.userData.wheelAxis = 'x'; // Changed from 'z' to 'x' for forward rotation
                                    }
                                }
                            });
                        } else if (currentCarName.includes('Patrol')) {
                            // Nissan Patrol transformations
                            carModel.scale.set(1.7, 1.7, 1.7);     // Changed from 2.0 to 1.7 as requested
                            
                            // ROTATE BY 180 DEGREES as explicitly requested
                            // Change from Math.PI to 0 (or from 0 to Math.PI) to rotate 180 degrees
                            carModel.rotation.y = 0;               // This is 180 degrees different from Math.PI
                            
                            carModel.position.y = 0.3;             // Lowered from 0.4 to 0.3 as requested
                            carModel.position.x = 0;               // Centered
                            carModel.position.z = 1.0;             // Move 1 meter forward
                            
                            // Enhanced wheel detection for Nissan Patrol
                            carModel.traverse(function(node) {
                                if (node.isMesh) {
                                    const name = node.name.toLowerCase();
                                    
                                    // Try to force rotation on all cylindrical objects as they might be wheels
                                    if (node.geometry && 
                                        (name.includes('wheel') || name.includes('tire') || name.includes('rim') ||
                                         name.includes('cerchio') || name.includes('roue') || name.includes('cilindro'))) {
                                        console.debug('Found potential wheel:', name);
                                        
                                        // Mark as wheel for rotation
                                        node.userData.isWheel = true;
                                        node.userData.wheelAxis = 'x';
                                    }
                                }
                            });
                            
                            // Add custom visible wheel markers for debugging
                            const wheelPositions = [
                                {x: -0.8, y: -0.5, z: 1.3},  // front left
                                {x: 0.8, y: -0.5, z: 1.3},   // front right
                                {x: -0.8, y: -0.5, z: -1.3}, // rear left
                                {x: 0.8, y: -0.5, z: -1.3}   // rear right
                            ];
                            
                            // Create and add visible wheels
                            wheelPositions.forEach((pos, i) => {
                                // Create wheel
                                const wheelGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.15, 32);
                                const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                                const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
                                
                                // Position the wheel
                                wheel.position.set(pos.x, pos.y, pos.z);
                                wheel.rotation.z = Math.PI / 2; // Align cylinder to be a wheel
                                
                                // Mark as wheel
                                wheel.userData.isWheel = true;
                                wheel.userData.wheelAxis = 'x';
                                wheel.name = `CustomWheel_${i}`;
                                
                                // Add to car model
                                carModel.add(wheel);
                                
                                console.debug('Added custom wheel:', wheel.name);
                            });
                        } else if (currentCarName.includes('Dragster')) {
                            // Top Fuel Dragster transformations - increased scale to ensure visibility
                            carModel.scale.set(0.7, 0.7, 0.7); // Updated from 0.5 to 0.7 as requested
                            
                            // Add position to lift the model above the floor
                            carModel.position.y = 0.5; // Lift the model up to prevent floor penetration
                            
                            // Fix wheel rotation axes for dragster
                            carModel.traverse(function(node) {
                                if (node.isMesh) {
                                    const name = node.name.toLowerCase();
                                    // Find wheel meshes by name
                                    if (name.includes('wheel') || name.includes('tire') || name.includes('rim') || 
                                        name.includes('roda') || name.includes('cerch') || name.includes('rad') || 
                                        name.includes('tyre') || name.includes('roue')) {
                                        
                                        console.warn('Found dragster wheel:', name);
                                        // Mark as wheel and set proper rotation axis
                                        node.userData.isWheel = true;
                                        node.userData.wheelAxis = 'x'; // Set X as the rotation axis for proper spinning
                                    }
                                }
                            });
                            
                            // Remove debug red color and sphere
                            // Comment out or remove the debug coloring and sphere
                            /*
                            // Make the model bright red to make it more visible for debugging
                            carModel.traverse(function(node) {
                                if (node.isMesh) {
                                    console.warn('Found dragster mesh:', node.name);
                                    node.material.emissive = new THREE.Color(1, 0, 0);
                                    node.material.emissiveIntensity = 0.5;
                                }
                            });
                            
                            // Add a debug sphere to show where the model should be
                            const debugSphere = new THREE.Mesh(
                                new THREE.SphereGeometry(1, 16, 16),
                                new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
                            );
                            debugSphere.position.set(0, 0, 0);
                            carModel.add(debugSphere);
                            */
                        } else {
                            // Ford Mustang transformations
                            carModel.scale.set(1.5, 1.5, 1.5); // Changed from 1.0 to 1.5 as requested
                            carModel.rotation.y = 0;
                            carModel.position.y = 0.5; // Adjusted higher to prevent floor penetration
                        }
                        
                        // Enable shadows on all meshes
                        carModel.traverse(function(node) {
                            if (node.isMesh) {
                                node.castShadow = true;
                                node.receiveShadow = true;
                                console.debug('Found mesh in model:', node.name);
                                
                                // Fix glass transparency for Porsche windows
                                if (currentCarName.includes('Porsche') && 
                                    (node.name.includes('window') || node.name.includes('glass') || 
                                     (node.material && (
                                         node.material.name?.includes('window') || 
                                         node.material.name?.includes('glass')
                                     )))) {
                                    if (node.material) {
                                        node.material.transparent = true;
                                        node.material.opacity = 0.0; // Completely transparent windows (no tint)
                                        node.material.refractionRatio = 0.98; // Higher refraction ratio
                                        node.material.envMapIntensity = 1.0; // Standard reflection intensity
                                        console.debug('Fixed transparency for:', node.name);
                                    }
                                }
                            }
                        });
                        
                        // Add model to car group
                        car.add(carModel);
                        console.debug('Model successfully added to scene');
                        
                        // Log bounding box to confirm visibility
                        const box = new THREE.Box3().setFromObject(carModel);
                        console.debug('Model bounding box:', 
                            'min:', box.min.x.toFixed(2), box.min.y.toFixed(2), box.min.z.toFixed(2),
                            'max:', box.max.x.toFixed(2), box.max.y.toFixed(2), box.max.z.toFixed(2));
                    },
                    function(xhr) {
                        console.debug(`Loading progress: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
                    },
                    function(error) {
                        console.error(`Error loading from ${currentPath}:`, error);
                        // Try the next path
                        tryNextPath(index + 1);
                    }
                );
            }
            
            // Alternative loading approach as last resort
            function tryAlternativeLoading() {
                console.debug('⚠️ Browser security is preventing local file access.');
                console.debug('For best results, please run this from a local web server.');
                console.debug('Creating simple car model instead.');
                
                // Skip the OBJ loader attempt and go straight to the simple car
                createSimpleCarModel();
                
                /* Removing the OBJ placeholder model code
                try {
                    if (typeof THREE.OBJLoader !== 'undefined') {
                        const objLoader = new THREE.OBJLoader();
                        
                        // Try to load a sample OBJ file from the web as a last resort
                        objLoader.load(
                            'https://threejs.org/examples/models/obj/male02/male02.obj',
                            function(object) {
                                console.debug('OBJ model loaded as placeholder!');
                                carModel = object;
                                carModel.scale.set(0.5, 0.5, 0.5);
                                carModel.position.y = 0.5;
                                car.add(carModel);
                            },
                            null,
                            function(error) {
                                console.error('Even OBJ loading failed:', error);
                                createSimpleCarModel();
                            }
                        );
                    } else {
                        console.error('OBJLoader not available, using fallback');
                        createSimpleCarModel();
                    }
                } catch (e) {
                    console.error('Error in alternative loading:', e);
                    createSimpleCarModel();
                }
                */
            }
            
            // Fallback function to create a simple car if the model doesn't load
            function createSimpleCarModel() {
                console.debug('Creating simple car representation');
                console.debug('⚠️ To load the actual 3D model, you need to run this file using a local web server');
                console.debug('⚠️ Using VS Code with Live Server extension or Python simple server: python -m http.server');
                
                // Basic car dimensions - adjust based on current car
                const carDimensions = {
                    "mustang": {
                        width: 1.92,   // 75.5 inches
                        height: 1.38,  // 54.3 inches
                        length: 4.81,  // 189.4 inches
                        color: 0x900000 // Deep red for Ford Mustang
                    },
                    "porsche": {
                        width: 1.85,   // 72.8 inches
                        height: 1.30,  // 51.2 inches
                        length: 4.54,  // 178.7 inches
                        color: 0xd0d0d0 // Silver for Porsche
                    }
                };
                
                // Determine which car we're creating
                const carType = currentCarName.includes("Porsche") ? "porsche" : "mustang";
                const dimensions = carDimensions[carType];
                
                // Create a simple box for the car body
                const bodyGeometry = new THREE.BoxGeometry(dimensions.width, dimensions.height, dimensions.length);
                const bodyMaterial = new THREE.MeshStandardMaterial({ 
                    color: dimensions.color,
                    metalness: 0.7,
                    roughness: 0.3
                });
                
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = dimensions.height/2 - 1.05; // Extremely lowered to match the wheels positioned at -0.55
                body.castShadow = true;
                body.receiveShadow = true;
                car.add(body);
                
                // Create wheels with very low positions
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 32);
            const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
            
            // Front left wheel - position wheels with bottoms below ground level to ensure contact
                wheelFL = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFL.rotation.z = Math.PI / 2;
                wheelFL.position.set(-dimensions.width/2 - 0.15, -0.55, dimensions.length/3); // Lowered to match car position at -0.5
            wheelFL.castShadow = true;
            car.add(wheelFL);
            
            // Front right wheel
                wheelFR = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheelFR.rotation.z = Math.PI / 2;
                wheelFR.position.set(dimensions.width/2 + 0.15, -0.55, dimensions.length/3); // Lowered to match car position at -0.5
            wheelFR.castShadow = true;
            car.add(wheelFR);
            
            // Rear left wheel
                wheelBL = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheelBL.rotation.z = Math.PI / 2;
                wheelBL.position.set(-dimensions.width/2 - 0.15, -0.55, -dimensions.length/3); // Lowered to match car position at -0.5
                wheelBL.castShadow = true;
                car.add(wheelBL);
            
            // Rear right wheel
                wheelBR = new THREE.Mesh(wheelGeometry, wheelMaterial);
                wheelBR.rotation.z = Math.PI / 2;
                wheelBR.position.set(dimensions.width/2 + 0.15, -0.55, -dimensions.length/3); // Lowered to match car position at -0.5
                wheelBR.castShadow = true;
                car.add(wheelBR);
                
                console.debug('Simple car model created successfully with 4 wheels that will rotate properly');
            }
        }
        
        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('quarter-mile-time').style.display = 'none';
            
            // Initialize game variables
            isPlaying = true;
            // Position the car in the center of the left lane (-TRACK_WIDTH/4)
            car.position.set(-TRACK_WIDTH/4, -0.5, 5);
            camera.lookAt(car.position);
            speed = 0;
            acceleration = 0;
            distance = 0;
            steeringAngle = 0;
            quarterMileCrossed = false;
            quarterMileTime = 0;
            rpm = currentCarSpecs.idleRPM;
            currentGear = 1; // Start in first gear
            
            // Reset time display to ensure it shows for each race
            if (timeDisplay) {
                updateTimeDisplay(0);
            }
            
            // Initialize light system
            lightSequenceActive = true;
            lightSequenceStartTime = performance.now();
            currentLightState = 0;
            falseStart = false;
            raceStarted = false;
            startTime = 0; // Will be set when green light activates
            finishTime = 0; // Reset finish time
            initialPosition = car.position.z;
            
            // Reset all lights to off state
            for (let side = 0; side < lightObjects.length; side++) {
                for (let i = 0; i < lightObjects[side].length; i++) {
                    const light = lightObjects[side][i];
                    light.material.emissive.setHex(0x333333);
                    light.material.emissiveIntensity = 0.2;
                    light.userData.active = false;
                }
            }
            
            // Update gear indicator
            updateGearDisplay();
            
            // Reset camera orbit parameters
            cameraOrbitAngle = 0;
            cameraDistance = 20; // Changed to 20 as requested
            cameraHeight = 4; // Reduced from 5 to match the new proportions
            
            // Position camera using orbit parameters
            const cameraX = car.position.x + Math.sin(cameraOrbitAngle) * cameraDistance;
            const cameraZ = car.position.z - Math.cos(cameraOrbitAngle) * cameraDistance;
            camera.position.set(
                cameraX,
                car.position.y + cameraHeight,
                cameraZ
            );
            // Look directly at the car's position for consistent camera behavior
            camera.lookAt(car.position.x, car.position.y, car.position.z);
            
            // Show ready message
            document.getElementById('info').textContent = 'Get ready...';
        }
        
        function updateGearDisplay() {
            // Display N for neutral, or the current gear number
            document.getElementById('gear-value').textContent = currentGear === 0 ? 'N' : currentGear;
        }
        
        function shiftUp() {
            // Get maximum gear from the car's gear ratios array (subtract 1 because index 0 is neutral)
            const maxGear = currentCarSpecs.gearRatios.length - 1;
            
            if (currentGear < maxGear) {
                // Don't allow shifting too rapidly - enforce a minimum delay between shifts
                const now = performance.now();
                if (now - lastGearChangeTime < 300) return;
                
                // Store current RPM for more natural transition
                const previousRPM = rpm;
                
                // Store current speed to maintain it through gear changes
                const currentSpeed = speed;
                
                // Simulate clutch engagement
                clutchEngaged = true;
                lastClutchEngageTime = now;
                setTimeout(() => {
                    // Increase gear
                    currentGear++;
                    
                    // Adjust RPM based on speed and new gear ratio
                    // If we're in gear (not neutral), calculate RPM from speed
                    if (currentGear > 0) {
                        rpm = calculateRPMFromSpeed(currentSpeed, currentGear);
                    } else {
                        // In neutral, RPM is decoupled from speed
                        rpm = currentCarSpecs.idleRPM;
                    }
                    
                    // Update display
                    updateGearDisplay();
                    clutchEngaged = false;
                    lastGearChangeTime = now;
                    
                    // Activate momentum change indicator
                    showMomentumChange('up');
                }, 200);
            }
        }
        
        function shiftDown() {
            if (currentGear > 0) {  // Allow shifting down to neutral (0)
                // Don't allow shifting too rapidly
                const now = performance.now();
                if (now - lastGearChangeTime < 300) return;
                
                // Store current RPM and speed for transitions
                const previousRPM = rpm;
                const currentSpeed = speed;
                
                // Simulate clutch engagement
                clutchEngaged = true;
                lastClutchEngageTime = now;
                setTimeout(() => {
                    // Decrease gear
                    currentGear--;
                    
                    // Update RPM based on new gear
                    if (currentGear > 0) {
                        // If still in a gear, calculate new RPM from current speed and gear ratio
                        rpm = calculateRPMFromSpeed(currentSpeed, currentGear);
                        
                        // Prevent over-revving on downshift
                        rpm = Math.min(rpm, currentCarSpecs.redlineRPM + 500);
                    } else {
                        // In neutral, RPM is decoupled from speed
                        // Start with previous RPM (decoupled from wheels)
                        rpm = previousRPM * 0.9; // Small drop when going to neutral
                    }
                    
                    updateGearDisplay();
                    clutchEngaged = false;
                    lastGearChangeTime = now;
                    
                    // Activate momentum change indicator
                    showMomentumChange('down');
                }, 200);
            }
        }
        
        function switchToNeutral() {
            if (currentGear !== 0) {
                // Don't allow shifting too rapidly - enforce a minimum delay between shifts
                const now = performance.now();
                if (now - lastGearChangeTime < 300) return;
                
                // Save the RPM before going to neutral
                const previousRPM = rpm;
                // Save current speed - we will maintain this during shifting
                const currentSpeed = speed;
                
                // Show momentum preserved indicator
                showMomentumIndicator();
                
                // Simulate clutch push
                clutchEngaged = true;
                lastClutchEngageTime = now; // Record when clutch was engaged
                setTimeout(() => {
                    currentGear = 0;
                    
                    // When switching to neutral, RPM gradually falls to idle
                    // but doesn't instantly drop. Start with the current RPM
                    // and let the update function gradually reduce it to idle.
                    
                    // Add a slight drop for going to neutral but not all the way to idle immediately
                    rpm = Math.max(previousRPM * 0.9, currentCarSpecs.idleRPM);
                    
                    // IMPORTANT: Speed should be maintained when going to neutral due to momentum
                    // The car's momentum doesn't change instantly
                    speed = currentSpeed;
                    
                    clutchEngaged = false;
                    updateGearDisplay();
                    lastGearChangeTime = now;
                }, 200);
            }
        }
        
        function handleAutomaticTransmission(speed, rpm) {
            if (!isAutomaticTransmission) return;
            
            // Don't shift automatically if clutch is engaged or if in neutral
            if (clutchEngaged || currentGear === 0) return;
            
            // Don't shift if we recently shifted (prevent oscillation)
            const now = performance.now();
            if (now - lastGearChangeTime < 1000) return;
            
            // Get maximum gear from the car's gear ratios array (subtract 1 because index 0 is neutral)
            const maxGear = currentCarSpecs.gearRatios.length - 1;
            
            // Get max speed in current gear and next gear
            const currentGearMaxSpeed = calculateMaxSpeedInGear(currentGear);
            const nextGearMaxSpeed = currentGear < maxGear ? calculateMaxSpeedInGear(currentGear + 1) : Infinity;
            
            // Automatic upshift logic - upshift when approaching redline
            if (rpm > currentCarSpecs.redlineRPM - 500 && currentGear < 10) {
                shiftUp();
                return;
            }
            
            // Automatic downshift logic
            if (currentGear > 1) {
                // Calculate what the RPM would be in the lower gear
                const lowerGearRPM = calculateRPMFromSpeed(speed, currentGear - 1);
                
                // Only downshift if:
                // 1. RPM in lower gear would be in a good power band (not too high)
                // 2. Current RPM is low enough that we need more power
                // 3. Car is moving
                if (lowerGearRPM > currentCarSpecs.idleRPM + 500 && 
                    lowerGearRPM < currentCarSpecs.redlineRPM - 1000 && 
                    rpm < currentCarSpecs.torquePeakRPM * 0.6 &&
                    speed > 1.0) {
                    shiftDown();
                }
            }
        }
        
        function toggleTransmissionMode() {
            isAutomaticTransmission = !isAutomaticTransmission;
            
            const toggle = document.getElementById('transmission-toggle');
            const status = document.getElementById('transmission-status');
            
            if (isAutomaticTransmission) {
                toggle.classList.remove('manual');
                toggle.classList.add('automatic');
                status.textContent = 'AUTOMATIC';
            } else {
                toggle.classList.remove('automatic');
                toggle.classList.add('manual');
                status.textContent = 'MANUAL';
            }
        }
        
        function calculateRPMFromSpeed(speedMPS, gear) {
            if (gear === 0) return currentCarSpecs.idleRPM; // Neutral
            if (speedMPS < 0.1) return currentCarSpecs.idleRPM; // Stationary
            
            // Convert speed from m/s to rpm using gear ratios
            // RPM = (speed in m/s * 60 * gear ratio * final drive ratio) / (π * wheel diameter)
            const wheelCircumference = Math.PI * currentCarSpecs.wheelDiameter;
            const gearRatio = currentCarSpecs.gearRatios[gear];
            const finalDriveRatio = currentCarSpecs.finalDriveRatio;
            
            let calculatedRPM = (speedMPS * 60 * gearRatio * finalDriveRatio) / wheelCircumference;
            
            // Add a small random fluctuation to make the RPM gauge movement more realistic
            const fluctuation = Math.sin(performance.now() / 200) * 50;
            calculatedRPM += fluctuation;
            
            // Ensure RPM doesn't go below idle when in gear and moving
            calculatedRPM = Math.max(calculatedRPM, currentCarSpecs.idleRPM);
            
            return calculatedRPM;
        }
        
        function calculateMaxSpeedInGear(gear) {
            if (gear === 0) return 0; // Neutral
            
            // Maximum vehicle speed in this gear at redline
            // Speed (m/s) = (rpm * π * wheel diameter) / (60 * gear ratio * final drive ratio)
            const wheelCircumference = Math.PI * currentCarSpecs.wheelDiameter;
            const gearRatio = currentCarSpecs.gearRatios[gear];
            const finalDriveRatio = currentCarSpecs.finalDriveRatio;
            
            const maxSpeedMPS = (currentCarSpecs.redlineRPM * wheelCircumference) / (60 * gearRatio * finalDriveRatio);
            return maxSpeedMPS;
        }
        
        function calculateTorque(rpm) {
            // Get current car specs
            const idleRPM = currentCarSpecs.idleRPM;
            const peakTorqueRPM = currentCarSpecs.torquePeakRPM;
            const peakPowerRPM = currentCarSpecs.powerPeakRPM;
            const maxRPM = currentCarSpecs.maxRPM;
            const maxTorque = currentCarSpecs.maxTorque;
            const redlineRPM = currentCarSpecs.redlineRPM;
            
            if (rpm < idleRPM) return 0;
            
            // Below idle RPM
            if (rpm < idleRPM) {
                return 0;
            }
            
            // For Porsche - flatter torque curve with earlier peak
            if (currentCarName.includes("Porsche")) {
                // From idle to 2000 RPM
                if (rpm >= idleRPM && rpm < 2000) {
                    return maxTorque * 0.8 * (1 + 0.2 * (rpm - idleRPM) / (2000 - idleRPM));
                }
                
                // From 2000 to peak torque RPM
                if (rpm >= 2000 && rpm < peakTorqueRPM) {
                    return maxTorque * 0.9 + maxTorque * 0.1 * (rpm - 2000) / (peakTorqueRPM - 2000);
                }
                
                // Flat torque plateau from peak torque to 4500 RPM
                if (rpm >= peakTorqueRPM && rpm < 4500) {
                    return maxTorque;
                }
                
                // From 4500 to peak power
                if (rpm >= 4500 && rpm < peakPowerRPM) {
                    return maxTorque * (1 - 0.05 * (rpm - 4500) / (peakPowerRPM - 4500));
                }
                
                // From peak power to redline
                if (rpm >= peakPowerRPM && rpm <= redlineRPM) {
                    return maxTorque * 0.95 * (1 - 0.15 * (rpm - peakPowerRPM) / (redlineRPM - peakPowerRPM));
                }
                
                // Past redline
                if (rpm > redlineRPM) {
                    return maxTorque * 0.8 * Math.max(0, 1 - (rpm - redlineRPM) / 400);
                }
            } else {
                // Original Mustang torque curve
            
            // From idle to 2000 RPM - torque builds up more quickly for supercharged engine
            if (rpm >= idleRPM && rpm < 2000) {
                return maxTorque * 0.75 * (1 + 0.25 * (rpm - idleRPM) / (2000 - idleRPM));
            }
            
            // From 2000 to peak torque RPM - torque increases more rapidly with supercharger
            if (rpm >= 2000 && rpm < peakTorqueRPM) {
                return maxTorque * 0.88 + maxTorque * 0.12 * (rpm - 2000) / (peakTorqueRPM - 2000);
            }
            
            // At peak torque - flatter torque curve for supercharged engine
            if (rpm >= peakTorqueRPM && rpm < peakPowerRPM) {
                // Much flatter torque curve from peak torque to peak power with supercharger
                return maxTorque * (1 - 0.02 * (rpm - peakTorqueRPM) / (peakPowerRPM - peakTorqueRPM));
            }
            
            // From peak power to redline - torque decreases less with supercharger
                if (rpm >= peakPowerRPM && rpm <= redlineRPM) {
                    return maxTorque * 0.98 * (1 - 0.15 * (rpm - peakPowerRPM) / (redlineRPM - peakPowerRPM));
            }
            
            // Past redline - torque falls rapidly
                if (rpm > redlineRPM) {
                    return maxTorque * 0.8 * Math.max(0, 1 - (rpm - redlineRPM) / 500);
                }
            }
            
            return 0; // Fallback
        }
        
        function calculateDragForce(speed) {
            // F_drag = 0.5 * density * v² * drag_coefficient * frontal_area
            return 0.5 * AIR_DENSITY * speed * speed * currentCarSpecs.dragCoefficient * currentCarSpecs.frontalArea;
        }
        
        function calculateRollingResistance(speed) {
            // F_rolling = C_rr * m * g * (1 + speed/100)
            // The speed term accounts for increased resistance at higher speeds
            return ROLLING_RESISTANCE_COEF * currentCarSpecs.weight * GRAVITY * (1 + speed/100);
        }
        
        function showQuarterMileTime(time) {
            const quarterMileDisplay = document.getElementById('quarter-mile-time');
            document.getElementById('quarter-mile-value').textContent = time.toFixed(3) + 's';
            quarterMileDisplay.style.display = 'block';
            
            // Hide the display and restart after 5 seconds
            setTimeout(() => {
                quarterMileDisplay.style.display = 'none';
                resetAfterQuarterMile();
            }, 5000);
        }
        
        function resetAfterQuarterMile() {
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('startButton').textContent = 'RACE AGAIN';
            isPlaying = false;
            
            // Reset time display to ensure it shows on subsequent races
            if (timeDisplay) {
                updateTimeDisplay(0);
            }
        }
        
        function updateGame(timestamp) {
            if (!isPlaying) return;
            
            // Calculate time delta - make sure we're using the actual timestamp parameter
            const delta = (timestamp - (lastFrameTime || timestamp)) / 1000; // Convert to seconds
            lastFrameTime = timestamp;
            
            // Limit delta to prevent physics issues during lag spikes
            const cappedDelta = Math.min(delta, 0.1);
            
            // Update light sequence
            updateLightSequence(timestamp);
            
            // If false start detected, prevent further updates
            if (falseStart) {
                return;
            }
            
            // Debug timestamp and delta to help diagnose issues
            if (Math.random() < 0.01) { // Only log occasionally
                console.log('Timestamp:', timestamp, 'Delta:', delta.toFixed(5), 'Capped Delta:', cappedDelta.toFixed(5));
            }
            
            // Update time display banner
            if (startTime > 0 && raceStarted) {
                // Race is ongoing, update with current elapsed time
                let currentElapsedTime = (timestamp - startTime) / 1000; // Convert to seconds
                
                // If race is finished, use the final time
                if (finishTime > 0) {
                    currentElapsedTime = (finishTime - startTime) / 1000;
                }
                
                // Update time display
                if (timeDisplay) {
                    updateTimeDisplay(currentElapsedTime);
                }
            } else if (timeDisplay) {
                // Race hasn't started yet, display zeros
                updateTimeDisplay(0);
            }
            
            // Calculate clutch transition for smoother effects
            let clutchTransition = 0; // 0 = fully disengaged, 1 = fully engaged
            if (clutchEngaged) {
                const timeSinceClutchEngaged = timestamp - lastClutchEngageTime;
                clutchTransition = Math.min(1, timeSinceClutchEngaged / 200);
            }
            
            // Handle gear shifting for manual mode
            const now = performance.now();
            
            if (!isAutomaticTransmission) {
                // Manual mode - only process shift inputs if enough time has passed since last input
                if (keys['e'] && !keyPressTracking['e'] && now - lastShiftInput > 300) {
                    keyPressTracking['e'] = true;
                    lastShiftInput = now;
                    shiftUp();
                    revLimiterActive = false; // Reset rev limiter when shifting up
                }
                
                if (keys['q'] && !keyPressTracking['q'] && now - lastShiftInput > 300) {
                    keyPressTracking['q'] = true;
                    lastShiftInput = now;
                    shiftDown();
                }
                
                // Add a specific key for shifting directly to neutral (N key)
                if (keys['n'] && !keyPressTracking['n'] && now - lastShiftInput > 300) {
                    keyPressTracking['n'] = true;
                    lastShiftInput = now;
                    
                    // Only do something if we're not already in neutral
                    if (currentGear !== 0) {
                        // Store current RPM and speed
                        const previousRPM = rpm;
                        const currentSpeed = speed;
                        
                        // Engage clutch
                        clutchEngaged = true;
                        lastClutchEngageTime = now;
                        
                        // Shift to neutral
                        setTimeout(() => {
                            currentGear = 0;
                            // Slight RPM drop when going to neutral
                            rpm = Math.max(previousRPM * 0.9, currentCarSpecs.idleRPM);
                            updateGearDisplay();
                            clutchEngaged = false;
                            lastGearChangeTime = now;
                            
                            // Show neutral indicator
                            showMomentumChange('neutral');
                        }, 200);
                    }
                }
            } else {
                // In automatic mode, handle transmission shifts automatically
                handleAutomaticTransmission(speed, rpm);
            }
            
            // Calculate forces acting on the car
            let engineForce = 0;
            let brakingForce = 0;
            
            // Always allow car movement, regardless of light state
            if (keys['w']) {
                // Throttle is applied
                if (currentGear > 0) {
                    // Calculate torque at current RPM
                    const torque = calculateTorque(rpm);
                    
                    // Calculate gear ratio including final drive
                    const gearRatio = currentCarSpecs.gearRatios[currentGear];
                    const finalDriveRatio = currentCarSpecs.finalDriveRatio;
                    const totalRatio = gearRatio * finalDriveRatio;
                    
                    // Force at wheels = torque * total ratio / wheel radius
                    const rawEngineForce = (torque * totalRatio) / (currentCarSpecs.wheelDiameter / 2);
                    
                    // Apply clutch effect - when clutch is engaged (pressed down), less power is transferred
                    // When clutch is fully engaged, only residual force is transferred by friction
                    if (clutchEngaged) {
                        // When clutch is pressed, only a small amount of force is transferred
                        engineForce = rawEngineForce * CLUTCH_SLIP_FACTOR;
                    } else {
                        // When clutch is not pressed, full power is transferred
                        engineForce = rawEngineForce;
                    }
                    
                    // Debug torque and force calculation
                    if (Math.random() < 0.05) { // Only log occasionally to avoid console spam
                        console.log('Torque:', torque.toFixed(2), 'Total Ratio:', totalRatio.toFixed(2), 'Engine Force:', engineForce.toFixed(2));
                    }
                    
                    // Simulate wheel slip with high torque in lower gears
                    if (currentGear <= 2 && engineForce > currentCarSpecs.weight * 0.5 * GRAVITY) {
                        // Wheel slip reduces effective force when traction is lost
                        // Improved traction control for better launches
                        let slipFactor;
                        
                        // AWD cars have better traction as power is distributed to all wheels
                        if (currentCarSpecs.drivetrain === "AWD") {
                            // AWD cars have better traction, less wheel slip
                            slipFactor = 0.80 - (currentGear - 1) * 0.1; // Changed from 0.85 to 0.80 for AWD
                            
                            // AWD cars can put down more power effectively
                            engineForce *= 1.10; // Reverted from 1.05 back to 1.10 (10% boost)
                        } else if (currentCarName.includes('Dragster')) {
                            // Special case for Top Fuel Dragster - optimized for straight line acceleration
                            // Pro dragsters have special tires and are designed for maximum traction
                            slipFactor = 0.92 - (currentGear - 1) * 0.05; // Much better traction than regular RWD
                            
                            // Dragsters are specialized for launching - no RWD penalty
                            engineForce *= 1.15; // 15% boost for specialized dragster setup
                            
                            console.log('Dragster special traction applied!');
                        } else {
                            // RWD cars have more wheel slip with high torque
                            slipFactor = 0.65 - (currentGear - 1) * 0.15; // Changed from 0.70 to 0.65 for RWD
                            
                            // RWD cars lose some power to wheel spin
                            engineForce *= 0.95; // Reverted from 0.90 back to 0.95 (5% penalty)
                        }
                        
                        engineForce *= slipFactor;
                        console.log('Wheel slip! Factor:', slipFactor.toFixed(2), 'Drivetrain:', currentCarSpecs.drivetrain);
                    }
                } else if (currentGear === 0) {
                    // In neutral, gas pedal can rev engine but doesn't affect car's motion
                    const revRate = 3000; // RPM increase per second (increased for more responsive revving)
                    rpm += revRate * cappedDelta;
                    
                    // Limit RPM to max RPM + a small amount for the rev limiter effect
                    if (rpm > currentCarSpecs.redlineRPM) {
                        // Activate rev limiter when exceeding redline RPM
                        revLimiterActive = true;
                        
                        // Create a bouncing rev limiter effect at redline
                        rpm = currentCarSpecs.redlineRPM + Math.sin(timestamp / 50) * 200;
                        
                        // Add visual shake to car when hitting rev limiter
                        revLimiterShake = Math.sin(timestamp / 15) * 0.05;
                        
                        // Add camera shake for immersion
                        if (Math.random() < 0.1) {
                            camera.position.y += (Math.random() - 0.5) * 0.05;
                        }
                    }
                }
            } else if (keys['s']) {
                // Braking
                brakingForce = currentCarSpecs.weight * 0.8 * GRAVITY; // Strong braking force
            } else {
                // Neither gas nor brake - coasting
                // Engine braking if in gear, neutral RPM falloff if in neutral
                if (currentGear === 0) {
                    // In neutral, RPM falls toward idle when not pressing gas
                    const rpmDropRate = 1000; // RPM decrease per second
                    rpm -= rpmDropRate * cappedDelta;
                    rpm = Math.max(rpm, currentCarSpecs.idleRPM); // Don't drop below idle
                    
                    // Reset rev limiter effects when not pressing gas
                    revLimiterActive = false;
                    revLimiterShake = 0;
                }
            }
            
            // Calculate drag and rolling resistance
            const dragForce = calculateDragForce(speed);
            const rollingResistance = calculateRollingResistance(speed);
            
            // Total resistance
            const totalResistance = dragForce + rollingResistance + brakingForce;
            
            // Net force = engine force - resistance
            const netForce = engineForce - totalResistance;
            
            // Calculate acceleration (F = ma)
            acceleration = netForce / currentCarSpecs.weight;
            
            // Debug forces occasionally
            if (Math.random() < 0.02) {
                console.log('Forces (N) - Engine:', engineForce.toFixed(2), 
                            'Drag:', dragForce.toFixed(2), 
                            'Rolling:', rollingResistance.toFixed(2), 
                            'Braking:', brakingForce.toFixed(2), 
                            'Net:', netForce.toFixed(2),
                            'Acceleration:', acceleration.toFixed(4));
            }
            
            // Check if we're hitting speed limiter for current gear
            if (!isAutomaticTransmission && currentGear > 0) {
                const maxSpeedInGear = calculateMaxSpeedInGear(currentGear);
                
                // If we're approaching the max speed for this gear
                if (speed >= maxSpeedInGear * 0.98) {
                    revLimiterActive = true;
                    // Greatly reduce acceleration when hitting rev limiter
                    acceleration *= 0.05;
                } else {
                    revLimiterActive = false;
                }
            }
            
            // Update speed based on acceleration
            if (!clutchEngaged) {
                speed += acceleration * cappedDelta;
                
                // Clamp speed to gear's maximum speed only if in gear (not neutral)
                if (currentGear > 0) {
                    const maxSpeedInGear = calculateMaxSpeedInGear(currentGear);
                    speed = Math.min(speed, maxSpeedInGear * 1.02); // Allow slight overrev
                }
            } else {
                // If clutch is engaged, car only slows down due to friction and drag forces
                // Instead of artificially reducing speed, calculate proper deceleration
                // due to rolling resistance and air drag
                const dragForce = calculateDragForce(speed);
                const rollingResistance = calculateRollingResistance(speed);
                
                // Calculate deceleration from drag and rolling resistance
                const frictionDeceleration = (dragForce + rollingResistance) / currentCarSpecs.weight;
                
                // Apply the proper deceleration from friction
                speed -= frictionDeceleration * cappedDelta;
            }
            
            speed = Math.max(0, speed); // Prevent negative speed
            
            // Update RPM based on speed and gear
            if (!clutchEngaged) {
                if (currentGear > 0) {
                    // If in gear, calculate RPM from wheel speed
                    let calculatedRPM = calculateRPMFromSpeed(speed, currentGear);
                    
                    // For manual mode, implement rev limiter behavior
                    if (!isAutomaticTransmission && revLimiterActive) {
                        // Make RPM bounce against redline in manual mode
                        const bounceAmount = Math.sin(performance.now() / 30) * 200;
                        revLimiterShake = (Math.random() - 0.5) * 0.03; // Random shake for visual effect
                        
                        // Simulate RPM bouncing between redline and slightly below
                        rpm = currentCarSpecs.redlineRPM - 100 + bounceAmount;
                    } else {
                        rpm = calculatedRPM;
                        revLimiterShake = 0;
                    }
                }
                // If in neutral, RPM is already handled in the throttle/brake logic above
            } else {
                // More realistic clutch behavior:
                // RPM gradually falls when clutch is engaged but doesn't immediately drop to idle
                
                if (currentGear === 0) {
                    // In neutral, RPM gradually returns to idle with a gentle decay
                    rpm = rpm * 0.99 + currentCarSpecs.idleRPM * 0.01;
                } else {
                    // When clutch is engaged in gear, RPM falls more slowly than in neutral
                    // and incorporates a small random variation to simulate engine load fluctuations
                    const randomFactor = 1 + (Math.random() - 0.5) * 0.01; // Small random variation
                    rpm = rpm * 0.98 * randomFactor + currentCarSpecs.idleRPM * 0.02;
                    
                    // If gas pedal is pressed during clutch engagement, allow some rev building
                    if (keys['w']) {
                        // Allow the engine to rev up while clutch is engaged
                        const revRate = 800; // RPM increase per second
                        rpm += revRate * cappedDelta; 
                    }
                }
                
                revLimiterActive = false;
                revLimiterShake = 0;
            }
            
            // Clamp RPM to ensure it doesn't exceed the engine's maximum
            rpm = Math.max(currentCarSpecs.idleRPM, Math.min(rpm, currentCarSpecs.maxRPM + 200)); // Allow slight overrev for visual effect
            
            // Handle auto-upshift at redline to prevent damage - ONLY IN AUTOMATIC MODE
            if (isAutomaticTransmission && rpm >= currentCarSpecs.redlineRPM - 200 && currentGear < 10 && !clutchEngaged) {
                shiftUp();
            }
            
            // Update steering
            if (keys['a']) {
                steeringAngle = Math.min(steeringAngle + 1 * cappedDelta, 0.3); // Reduced max angle from 0.5 to 0.3
            } else if (keys['d']) {
                steeringAngle = Math.max(steeringAngle - 1 * cappedDelta, -0.3); // Reduced max angle from -0.5 to -0.3
            } else {
                // Return steering to center more quickly
                steeringAngle *= 0.8; // Was 0.9, now returns to center faster
            }
            
            // Update the car position and appearance
            if (car) {
                // Apply physics-based movement
                const movementDistance = speed * cappedDelta;
                car.position.z += movementDistance;
                
                // Update distance
                distance = car.position.z - initialPosition;
                
                // Apply steering
                car.position.x += steeringAngle * movementDistance;
                
                // Keep car within track boundaries
                const trackHalfWidth = TRACK_WIDTH / 2;
                car.position.x = Math.max(-trackHalfWidth + 1.2, Math.min(trackHalfWidth - 1.2, car.position.x));
                
                // Add rev limiter shake effect when active
                let xShake = 0;
                let yShake = 0;
                
                if (revLimiterActive) {
                    // Create shake effect for rev limiter
                    xShake = Math.sin(timestamp / 20) * 0.02;
                    yShake = Math.sin(timestamp / 15) * 0.01;
                }
                
                // Apply position with shake if rev limiter is active
                car.position.set(
                    car.position.x + xShake,
                    car.position.y + yShake,
                    car.position.z
                );
                
                // Apply steering rotation plus additional shake if rev limiter is active
                car.rotation.y = -steeringAngle * 0.8 + (revLimiterActive ? Math.sin(timestamp / 25) * 0.01 : 0);
                
                // Update wheels to rotate based on speed and steering
                try {
                    // Calculate wheel rotation speed based on car speed
                    const wheelRadius = 0.4;
                    const wheelRotationSpeed = speed / wheelRadius;
                    
                    // Special debug for Nissan Patrol
                    if (currentCarName.includes('Patrol')) {
                        console.debug('Updating Nissan Patrol wheels, speed:', speed);
                        
                        // Find all custom wheel objects by name
                        const customWheels = [];
                        carModel.traverse((node) => {
                            if (node.name && node.name.includes('CustomWheel_')) {
                                customWheels.push(node);
                                
                                // Apply rotation directly to custom wheels - known to be oriented properly
                                node.rotation.x += wheelRotationSpeed * cappedDelta;
                            }
                        });
                        
                        console.debug('Found custom wheels:', customWheels.length);
                    }
                    
                    // Check if we have a GLTF model loaded
                    if (carModel) {
                        console.debug('Animating GLTF model wheels');
                        
                        // Find wheels in the model
                        carModel.traverse(function(node) {
                            if (node.isMesh) {
                                // Enhanced wheel detection for all car models including Nissan Patrol
                                const name = node.name.toLowerCase();
                                const isWheel = name.includes('wheel') || name.includes('tire') || name.includes('rim') || 
                                    name.includes('roda') || name.includes('cerch') || name.includes('rad') || 
                                    name.includes('tyre') || name.includes('roue') || name.includes('roue') ||
                                    (node.userData && node.userData.isWheel);
                                
                                if (isWheel) {
                                    // For Nissan Patrol, log wheel rotation for debugging
                                    if (currentCarName.includes('Patrol')) {
                                        console.debug('Rotating wheel in Nissan Patrol:', node.name);
                                    }
                                    
                                    // Special handling for dragster wheels
                                    if (currentCarName.includes('Dragster')) {
                                        // Dragster wheels should always rotate around X axis for proper spinning
                                        node.rotation.x += wheelRotationSpeed * cappedDelta;
                                    }
                                    // Apply rotation to wheel based on speed
                                    // Check if we have a stored wheel axis preference
                                    else if (node.userData && node.userData.wheelAxis) {
                                        if (node.userData.wheelAxis === 'z') {
                                            node.rotation.z += wheelRotationSpeed * cappedDelta;
                                        } else if (node.userData.wheelAxis === 'x') {
                                            node.rotation.x += wheelRotationSpeed * cappedDelta;
                                        } else if (node.userData.wheelAxis === 'y') {
                                            node.rotation.y += wheelRotationSpeed * cappedDelta;
                                        }
                                    } else {
                                        // Try multiple rotation axes for Nissan Patrol
                                        if (currentCarName.includes('Patrol')) {
                                            // Try both axes for Patrol model
                                            node.rotation.x += wheelRotationSpeed * cappedDelta;
                                            node.rotation.z += wheelRotationSpeed * cappedDelta;
                                        } else {
                                            // Default to Z axis for rotation for other models
                                            node.rotation.z += wheelRotationSpeed * cappedDelta;
                                        }
                                    }
                                }
                                
                                // If it's a front wheel, also apply steering
                                if (name.includes('front') || name.includes('fr') || name.includes('fl')) {
                                    node.rotation.y = steeringAngle * 0.8;
                                }
                            }
                        });
                    }
                    // Fallback for simple car model
                    else if (wheelFL) {
                        // Roll rotation for all wheels based on speed
                        wheelFL.rotation.x += wheelRotationSpeed * cappedDelta;
                        wheelFR.rotation.x += wheelRotationSpeed * cappedDelta;
                        wheelBL.rotation.x += wheelRotationSpeed * cappedDelta;
                        wheelBR.rotation.x += wheelRotationSpeed * cappedDelta;
                        
                        // Steering for front wheels
                        wheelFL.rotation.y = steeringAngle * 0.8;
                        wheelFR.rotation.y = steeringAngle * 0.8;
                    }
                } catch (e) {
                    console.error('Error updating wheels:', e);
                }
            }
            
            // Use orbit camera position
            const cameraX = car.position.x + Math.sin(cameraOrbitAngle) * cameraDistance;
            const cameraZ = car.position.z - Math.cos(cameraOrbitAngle) * cameraDistance;
            
            camera.position.set(
                cameraX,
                car.position.y + cameraHeight,
                cameraZ
            );
            camera.lookAt(car.position);
            
            // Update UI
            // Convert m/s to km/h for speed display (1 m/s = 3.6 km/h)
            const speedKMH = Math.round(speed * 3.6);
            document.getElementById('speedometer').textContent = `Speed: ${Math.round(speed * 2.237)} mph`;
            document.getElementById('distance').textContent = `Distance: ${distance.toFixed(2)} m`; // Show two decimal places
            
            // Update gauges
            const speedDisplay = document.querySelector('#speed-gauge .gauge-value');
            const speedMPH = Math.round(speed * 2.237); // Convert m/s to mph
            speedDisplay.textContent = speedMPH + ' mph';
            
            // Update secondary speed display (km/h)
            const speedSecondaryDisplay = document.querySelector('#speed-gauge .gauge-secondary-value');
            speedSecondaryDisplay.textContent = speedKMH + ' km/h';
            
            // Update speed bar (max 200 mph)
            const speedBar = document.querySelector('#speed-gauge .gauge-bar');
            const speedPercentage = Math.min(speedMPH / 200, 1) * 100;
            speedBar.style.width = `${speedPercentage}%`;
            
            // Update RPM display
            const rpmDisplay = document.querySelector('#rpm-gauge .gauge-value');
            rpmDisplay.textContent = Math.round(rpm).toLocaleString();
            
            // Update RPM bar
            const rpmBar = document.querySelector('#rpm-gauge .gauge-bar');
            const maxRPM = 11000; // Visual max for the gauge, increased from 9000 to 11000
            const rpmPercentage = Math.min(rpm / maxRPM, 1) * 100;
            rpmBar.style.width = `${rpmPercentage}%`;
            
            // Position the redline according to the car's specs
            const redline = document.querySelector('#rpm-gauge .gauge-redline');
            const redlinePercentage = (currentCarSpecs.redlineRPM / maxRPM) * 100;
            redline.style.left = `${redlinePercentage}%`;
            
            // Visual feedback for rev limiter
            if (revLimiterActive) {
                // Visual feedback for rev limiter
                rpmBar.style.boxShadow = '0 0 10px rgba(255, 0, 0, 0.8)';
                
                // Make the RPM text flash red
                rpmDisplay.style.color = Math.sin(timestamp / 100) > 0 ? '#ff3300' : '#ffffff';
            } else {
                // Reset effects
                rpmBar.style.boxShadow = 'none';
                rpmDisplay.style.color = '#ffffff';
            }
            
            // Update clouds
            updateClouds(cappedDelta);
            
            // Check if player has crossed the quarter mile mark - only if race properly started
            if (car.position.z - initialPosition >= QUARTER_MILE && !quarterMileCrossed && raceStarted && !falseStart) {
                quarterMileCrossed = true;
                quarterMileTime = (timestamp - startTime) / 1000; // Convert to seconds
                showQuarterMileTime(quarterMileTime);
            }
            
            // Check if player has finished the full race - only if race properly started
            if (car.position.z - initialPosition >= FINISH_LINE && finishTime === 0 && raceStarted && !falseStart) {
                finishTime = timestamp;
                const elapsedTime = (finishTime - startTime) / 1000; // Convert to seconds
                document.getElementById('info').textContent = `Finished! Time: ${elapsedTime.toFixed(2)} seconds`;
                
                // Allow car to continue driving in the cooldown area
                // Only reset when reaching the end of the extended track or after timeout
                if (car.position.z >= EXTENDED_TRACK_LENGTH - 10) {
                    resetAfterFinish();
                } else {
                    // Set a timeout as backup in case player stops
                    setTimeout(resetAfterFinish, 10000);
                }
            }
            
            // Update shadow camera to follow the car for better shadow alignment
            if (car && directionalLight && directionalLight.shadow) {
                // Point the light target at the car for better shadow alignment
                directionalLight.target.position.copy(car.position);
                directionalLight.target.updateMatrixWorld();
                
                // Optionally adjust the light to follow the car's Z position while maintaining a fixed offset
                // directionalLight.position.z = car.position.z + 25;
                
                // Force shadow map update next frame
                directionalLight.shadow.needsUpdate = true;
            }
        }
        
        function resetAfterFinish() {
            // Only reset if not already done
            if (!isPlaying) return;
            
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('startButton').textContent = 'RACE AGAIN';
            isPlaying = false;
            
            // Reset time display to ensure it shows on subsequent races
            if (timeDisplay) {
                updateTimeDisplay(0);
            }
            
            // Also reset all race-related variables
            finishTime = 0;
            startTime = 0;
            raceStarted = false;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Get current timestamp
            const now = performance.now();
            
            // Call updateGame with the current timestamp
            updateGame(now);
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            const key = event.key.toLowerCase();
            
            // Track keys for debug console toggle
            if (key === 'd') {
                dKeyPressed = true;
            }
            if (event.key === '`') {
                backtickKeyPressed = true;
            }
            
            // Toggle debug console when both d and backtick are pressed
            if (dKeyPressed && backtickKeyPressed) {
                // Debounce to prevent multiple toggles
                const now = performance.now();
                if (now - lastToggleTime > 300) { // 300ms debounce
                    toggleDebugConsole();
                    lastToggleTime = now;
                }
            }
            
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
                console.log('Key pressed:', key); // Add debug logging
            }
        }
        
        function onKeyUp(event) {
            const key = event.key.toLowerCase();
            
            // Track keys for debug console toggle
            if (key === 'd') {
                dKeyPressed = false;
            }
            if (event.key === '`') {
                backtickKeyPressed = false;
            }
            
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
                console.log('Key released:', key); // Add debug logging
                
                // Reset key press tracking for shift keys
                if (key === 'q' || key === 'e' || key === 'n') {
                    keyPressTracking[key] = false;
                }
            }
        }
        
        // Create dynamic clouds
        function createClouds() {
            // Create 20-30 clouds at different heights and positions
            const cloudCount = 25;
            
            for (let i = 0; i < cloudCount; i++) {
                const cloud = createCloudMesh();
                
                // Random position in the sky, but keep them high
                const angle = Math.random() * Math.PI * 2;
                const dist = 1000 + Math.random() * 3000;
                const height = 800 + Math.random() * 1000;
                
                cloud.position.set(
                    Math.cos(angle) * dist,
                    height,
                    Math.sin(angle) * dist
                );
                
                // Random rotation
                cloud.rotation.y = Math.random() * Math.PI * 2;
                
                // Random scale
                const scale = 20 + Math.random() * 40;
                cloud.scale.set(scale, scale * 0.6, scale);
                
                // Add to scene and store in our clouds array
                scene.add(cloud);
                
                // Store movement data with the cloud
                clouds.push({
                    mesh: cloud,
                    speed: 0.2 + Math.random() * 0.3, // Random slow speed
                    direction: new THREE.Vector3(
                        Math.random() * 2 - 1,
                        0,
                        Math.random() * 2 - 1
                    ).normalize()
                });
            }
        }
        
        // Create a single cloud mesh
        function createCloudMesh() {
            const group = new THREE.Group();
            
            // Create several spheres clustered together to form a cloud
            const cloudMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.9,
                roughness: 1.0
            });
            
            // Create main body of the cloud
            const mainSphere = new THREE.SphereGeometry(1, 7, 7);
            const main = new THREE.Mesh(mainSphere, cloudMaterial);
            group.add(main);
            
            // Add 5-7 smaller spheres around it
            const smallSphereCount = 5 + Math.floor(Math.random() * 3);
            for (let i = 0; i < smallSphereCount; i++) {
                const size = 0.6 + Math.random() * 0.4;
                const smallSphere = new THREE.SphereGeometry(size, 6, 6);
                const small = new THREE.Mesh(smallSphere, cloudMaterial);
                
                // Position around the main sphere
                small.position.set(
                    (Math.random() * 2 - 1) * 0.9,
                    (Math.random() * 2 - 1) * 0.5,
                    (Math.random() * 2 - 1) * 0.9
                );
                
                group.add(small);
            }
            
            return group;
        }
        
        // Update clouds positions
        function updateClouds(delta) {
            clouds.forEach(cloud => {
                // Move cloud in its direction at its speed
                cloud.mesh.position.x += cloud.direction.x * cloud.speed * delta;
                cloud.mesh.position.z += cloud.direction.z * cloud.speed * delta;
                
                // If cloud is too far, reset its position to the opposite side
                const distanceFromCenter = Math.sqrt(
                    cloud.mesh.position.x * cloud.mesh.position.x +
                    cloud.mesh.position.z * cloud.mesh.position.z
                );
                
                if (distanceFromCenter > 5000) {
                    // Reset to opposite side
                    cloud.mesh.position.x = -cloud.mesh.position.x * 0.8;
                    cloud.mesh.position.z = -cloud.mesh.position.z * 0.8;
                    
                    // Slightly vary the height
                    cloud.mesh.position.y = 800 + Math.random() * 1000;
                }
            });
        }
        
        // Initialize the game on load
        window.onload = init;
        
        // Add this function after the other helper functions
        function showMomentumIndicator() {
            // Show a visual cue that momentum is being preserved
            momentumIndicatorActive = true;
            
            // Clear any existing timeout
            if (momentumIndicatorTimeout) {
                clearTimeout(momentumIndicatorTimeout);
            }
            
            // Create a small indicator element if it doesn't exist
            let indicator = document.getElementById('momentum-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'momentum-indicator';
                indicator.style.position = 'absolute';
                indicator.style.bottom = '50px';
                indicator.style.left = '50%';
                indicator.style.transform = 'translateX(-50%)';
                indicator.style.padding = '5px 10px';
                indicator.style.backgroundColor = 'rgba(0, 255, 0, 0.7)';
                indicator.style.color = 'white';
                indicator.style.fontWeight = 'bold';
                indicator.style.borderRadius = '5px';
                indicator.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.7)';
                indicator.style.zIndex = '1000';
                indicator.style.transition = 'opacity 0.5s';
                indicator.style.opacity = '0';
                indicator.textContent = 'MOMENTUM PRESERVED';
                document.body.appendChild(indicator);
            }
            
            // Show the indicator
            indicator.style.opacity = '1';
            
            // Hide it after 1 second
            momentumIndicatorTimeout = setTimeout(() => {
                indicator.style.opacity = '0';
                momentumIndicatorActive = false;
            }, 1000);
        }
        
        // Update the light sequence for drag racing
        function updateLightSequence(timestamp) {
            if (!lightSequenceActive) return;
            
            const elapsed = timestamp - lightSequenceStartTime;
            
            // Time for each light in milliseconds - in real drag racing, lights activate with specific timing
            const lightTiming = [
                1000,   // Red light
                3000,   // Yellow light
                5000    // Green light
            ];
            
            // Determine current light state based on elapsed time
            let newLightState = 0;
            for (let i = 0; i < lightTiming.length; i++) {
                if (elapsed >= lightTiming[i]) {
                    newLightState = i + 1; // +1 because states start at 1 (1=red, 2=yellow, 3=green)
                }
            }
            
            // If light state changed, update the lights
            if (newLightState !== currentLightState) {
                currentLightState = newLightState;
                
                // Update light visuals - only one light is active at a time, like a traffic light
                for (let i = 0; i < lightObjects[0].length; i++) {
                    const light = lightObjects[0][i];
                    
                    if (i === currentLightState - 1) { // -1 to convert from 1-based state to 0-based array index
                        // Activate this light
                        light.material.emissive.setHex(light.userData.color);
                        light.material.emissiveIntensity = 1.0;
                        light.userData.active = true;
                    } else {
                        // Deactivate other lights
                        light.material.emissive.setHex(0x333333);
                        light.material.emissiveIntensity = 0.2;
                        light.userData.active = false;
                    }
                }
                
                // Update the light status message
                const lightStatus = document.getElementById('light-status');
                
                if (currentLightState === 1) {
                    // Red light
                    lightStatus.textContent = "STOP";
                    lightStatus.style.color = "#ff0000";
                    
                } else if (currentLightState === 2) {
                    // Yellow light
                    lightStatus.textContent = "PREPARE...";
                    lightStatus.style.color = "#ffff00";
                    
                } else if (currentLightState === 3) {
                    // Green light - check if car has moved from starting position
                    if (car.position.z > initialPosition + 0.2) {
                        // Car has moved - disqualify
                        falseStart = true;
                        lightStatus.textContent = "DISQUALIFIED - Car moved before green light!";
                        lightStatus.style.color = "#ff0000";
                        
                        // End the sequence
                        setTimeout(() => {
                            resetAfterFalseStart();
                        }, 3000);
                    } else {
                        // Car is still at starting position - valid start
                        lightStatus.textContent = "GO!";
                        lightStatus.style.color = "#00ff00";
                        
                        // Start the race timer
                        startTime = timestamp;
                        raceStarted = true;
                        document.getElementById('info').textContent = 'Race in progress';
                        
                        // Hide the status after a delay
                        setTimeout(() => {
                            lightStatus.style.opacity = '0';
                            setTimeout(() => {
                                lightStatus.style.opacity = '1';
                                lightStatus.textContent = '';
                            }, 500);
                        }, 2000);
                    }
                }
            }
            
            // If all lights have been processed, end the sequence
            if (elapsed >= lightTiming[lightTiming.length - 1] + 1000 && !falseStart) {
                lightSequenceActive = false;
            }
        }
        
        // Reset after false start
        function resetAfterFalseStart() {
            document.getElementById('startScreen').style.display = 'flex';
            document.getElementById('startButton').textContent = 'TRY AGAIN';
            isPlaying = false;
            
            // Reset time display to ensure it shows on subsequent races
            if (timeDisplay) {
                updateTimeDisplay(0);
            }
        }
        
        // Restart the game
        function restartGame() {
            // Reset the car position
            isPlaying = false;
            
            // Hide any result displays
            document.getElementById('quarter-mile-time').style.display = 'none';
            
            // Reset all state variables and restart the game
            setTimeout(() => {
                startGame();
            }, 100);
        }
        
        // Show momentum change indicator when shifting
        function showMomentumChange(direction) {
            // If a timeout is already active, clear it
            if (momentumIndicatorTimeout) {
                clearTimeout(momentumIndicatorTimeout);
            }
            
            // Create or get the indicator element
            let indicator = document.getElementById('momentum-indicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'momentum-indicator';
                indicator.style.position = 'absolute';
                indicator.style.top = '120px';
                indicator.style.width = '100%';
                indicator.style.textAlign = 'center';
                indicator.style.color = 'white';
                indicator.style.fontSize = '20px';
                indicator.style.zIndex = '150';
                indicator.style.textShadow = '0 0 5px black';
                indicator.style.opacity = '0';
                indicator.style.transition = 'opacity 0.3s ease-in-out';
                document.getElementById('container').appendChild(indicator);
            }
            
            // Set text based on direction
            if (direction === 'up') {
                indicator.textContent = '⬆️ SHIFTED UP';
                indicator.style.color = '#00ff00';
            } else if (direction === 'down') {
                indicator.textContent = '⬇️ SHIFTED DOWN';
                indicator.style.color = '#ffaa00';
            } else if (direction === 'neutral') {
                indicator.textContent = '⚠️ NEUTRAL';
                indicator.style.color = '#ff5500';
            }
            
            // Make visible
            indicator.style.opacity = '1';
            
            // Set timeout to hide
            momentumIndicatorTimeout = setTimeout(() => {
                indicator.style.opacity = '0';
            }, 800);
        }
        
        function createGuardRails() {
            const railHeight = 0.91; // Changed from 1.2 to 0.91 meters as requested
            const postSpacing = 5; // Space between posts
            const borderWidth = 1.5; // Reduced by 25% to match track border change
            
            // Create the main rail material - more realistic with subtle texture
            const railMaterial = new THREE.MeshStandardMaterial({
                color: 0xf0f0f0, // Slightly off-white
                metalness: 0.85,   
                roughness: 0.2,   
                flatShading: false,
                envMapIntensity: 1.3 // Enhanced reflections
            });
            
            // Create a slightly different material for the top rail
            const topRailMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff, // Pure white for the top
                metalness: 0.9,
                roughness: 0.15,
                flatShading: false,
                envMapIntensity: 1.5 // Strong reflections
            });
            
            // Create an enhanced version for the left top rail to make difference more noticeable
            const leftTopRailMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff, // Pure white for more contrast
                metalness: 0.95,
                roughness: 0.1,
                flatShading: false,
                emissive: 0x444444, // Enhanced emissive property for better visibility
                emissiveIntensity: 0.15,
                envMapIntensity: 1.7 // Maximum reflections
            });
            
            // Add surface imperfections to rail materials
            const textureLoader = new THREE.TextureLoader();
            // Create a procedural normal map for metal surface irregularities
            const normalMap = createNormalMapTexture();
            railMaterial.normalMap = normalMap;
            railMaterial.normalScale = new THREE.Vector2(0.15, 0.15); // Subtle normal effect
            topRailMaterial.normalMap = normalMap;
            topRailMaterial.normalScale = new THREE.Vector2(0.15, 0.15);
            leftTopRailMaterial.normalMap = normalMap;
            leftTopRailMaterial.normalScale = new THREE.Vector2(0.15, 0.15);
            
            // Add dirt texture overlay
            const dirtMap = createDirtTexture();
            railMaterial.aoMap = dirtMap; // Use as ambient occlusion to simulate dirt in crevices
            railMaterial.aoMapIntensity = 0.7; // Dirt intensity
            topRailMaterial.aoMap = dirtMap;
            topRailMaterial.aoMapIntensity = 0.6; // Slightly less dirt on top rail
            leftTopRailMaterial.aoMap = dirtMap;
            leftTopRailMaterial.aoMapIntensity = 0.4; // Even less dirt on left top rail
            
            // Create the post material - darker gray
            const postMaterial = new THREE.MeshStandardMaterial({
                color: 0x505050, // Darker gray for better contrast
                metalness: 0.5,
                roughness: 0.5,  // More roughness for posts
            });
            
            // LEFT SIDE GUARD RAIL
            // Main top rail - single continuous mesh
            const leftMainRailGeometry = new THREE.BoxGeometry(0.3, railHeight, TRACK_LENGTH);
            const leftMainRail = new THREE.Mesh(leftMainRailGeometry, leftTopRailMaterial);
            leftMainRail.position.set(-TRACK_WIDTH/2 - borderWidth - 0.2, railHeight/2, TRACK_LENGTH/2);
            leftMainRail.castShadow = true;
            leftMainRail.receiveShadow = true;
            scene.add(leftMainRail);
            
            // Secondary rail (lower beam) - single continuous mesh
            const leftLowerRailGeometry = new THREE.BoxGeometry(0.25, railHeight * 0.25, TRACK_LENGTH);
            const leftLowerRail = new THREE.Mesh(leftLowerRailGeometry, railMaterial);
            leftLowerRail.position.set(-TRACK_WIDTH/2 - borderWidth - 0.2, railHeight * 0.25, TRACK_LENGTH/2);
            leftLowerRail.castShadow = true;
            leftLowerRail.receiveShadow = true;
            scene.add(leftLowerRail);
            
            // Add posts at regular intervals
            const totalPosts = Math.ceil(TRACK_LENGTH / postSpacing);
            for (let i = 0; i < totalPosts; i++) {
                const z = i * postSpacing;
                if (z < TRACK_LENGTH) {
                    const postGeometry = new THREE.BoxGeometry(0.1, railHeight * 0.8, 0.15);
                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.set(-TRACK_WIDTH/2 - borderWidth - 0.2, railHeight * 0.4, z);
                    post.castShadow = true;
                    post.receiveShadow = true;
                    scene.add(post);
                }
            }
            
            // RIGHT SIDE GUARD RAIL
            // Main top rail - single continuous mesh
            const rightMainRailGeometry = new THREE.BoxGeometry(0.3, railHeight, TRACK_LENGTH);
            const rightMainRail = new THREE.Mesh(rightMainRailGeometry, topRailMaterial);
            rightMainRail.position.set(TRACK_WIDTH/2 + borderWidth + 0.2, railHeight/2, TRACK_LENGTH/2);
            rightMainRail.castShadow = true;
            rightMainRail.receiveShadow = true;
            scene.add(rightMainRail);
            
            // Secondary rail (lower beam) - single continuous mesh
            const rightLowerRailGeometry = new THREE.BoxGeometry(0.25, railHeight * 0.25, TRACK_LENGTH);
            const rightLowerRail = new THREE.Mesh(rightLowerRailGeometry, railMaterial);
            rightLowerRail.position.set(TRACK_WIDTH/2 + borderWidth + 0.2, railHeight * 0.25, TRACK_LENGTH/2);
            rightLowerRail.castShadow = true;
            rightLowerRail.receiveShadow = true;
            scene.add(rightLowerRail);
            
            // Add posts at regular intervals
            for (let i = 0; i < totalPosts; i++) {
                const z = i * postSpacing;
                if (z < TRACK_LENGTH) {
                    const postGeometry = new THREE.BoxGeometry(0.1, railHeight * 0.8, 0.15);
                    const post = new THREE.Mesh(postGeometry, postMaterial);
                    post.position.set(TRACK_WIDTH/2 + borderWidth + 0.2, railHeight * 0.4, z);
                    post.castShadow = true;
                    post.receiveShadow = true;
                    scene.add(post);
                }
            }
            
            // Add end caps to ensure complete guard rail enclosure with no gaps
            // Left front end cap
            const leftFrontCapGeometry = new THREE.BoxGeometry(0.3, railHeight, 0.3);
            const leftFrontCap = new THREE.Mesh(leftFrontCapGeometry, leftTopRailMaterial);
            leftFrontCap.position.set(-TRACK_WIDTH/2 - borderWidth - 0.2, railHeight/2, 0);
            leftFrontCap.castShadow = true;
            leftFrontCap.receiveShadow = true;
            scene.add(leftFrontCap);
            
            // Left back end cap
            const leftBackCapGeometry = new THREE.BoxGeometry(0.3, railHeight, 0.3);
            const leftBackCap = new THREE.Mesh(leftBackCapGeometry, leftTopRailMaterial);
            leftBackCap.position.set(-TRACK_WIDTH/2 - borderWidth - 0.2, railHeight/2, TRACK_LENGTH);
            leftBackCap.castShadow = true;
            leftBackCap.receiveShadow = true;
            scene.add(leftBackCap);
            
            // Right front end cap
            const rightFrontCapGeometry = new THREE.BoxGeometry(0.3, railHeight, 0.3);
            const rightFrontCap = new THREE.Mesh(rightFrontCapGeometry, topRailMaterial);
            rightFrontCap.position.set(TRACK_WIDTH/2 + borderWidth + 0.2, railHeight/2, 0);
            rightFrontCap.castShadow = true;
            rightFrontCap.receiveShadow = true;
            scene.add(rightFrontCap);
            
            // Right back end cap
            const rightBackCapGeometry = new THREE.BoxGeometry(0.3, railHeight, 0.3);
            const rightBackCap = new THREE.Mesh(rightBackCapGeometry, topRailMaterial);
            rightBackCap.position.set(TRACK_WIDTH/2 + borderWidth + 0.2, railHeight/2, TRACK_LENGTH);
            rightBackCap.castShadow = true;
            rightBackCap.receiveShadow = true;
            scene.add(rightBackCap);
        }
        
        // Function to create a procedural normal map texture
        function createNormalMapTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fill with neutral normal (128, 128, 255) - pointing straight out
            context.fillStyle = 'rgb(128, 128, 255)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some noise for surface irregularities
            for (let x = 0; x < canvas.width; x++) {
                for (let y = 0; y < canvas.height; y++) {
                    // Perturb the x,y components slightly
                    const xNoise = Math.floor(Math.random() * 20 - 10);
                    const yNoise = Math.floor(Math.random() * 20 - 10);
                    
                    // Draw small dots for normal map perturbation
                    if (Math.random() > 0.99) {
                        context.fillStyle = `rgb(${128 + xNoise}, ${128 + yNoise}, 255)`;
                        context.fillRect(x, y, 2, 2);
                    }
                    
                    // Add scratches occasionally
                    if (Math.random() > 0.995) {
                        const scratchLength = Math.random() * 10 + 5;
                        const angle = Math.random() * Math.PI * 2;
                        context.strokeStyle = `rgb(${128 + xNoise}, ${128 + yNoise}, 255)`;
                        context.beginPath();
                        context.moveTo(x, y);
                        context.lineTo(
                            x + Math.cos(angle) * scratchLength,
                            y + Math.sin(angle) * scratchLength
                        );
                        context.stroke();
                    }
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 10); // Repeat the texture for the guard rail length
            
            return texture;
        }
        
        // Function to randomize geometry vertices slightly for more realistic appearance
        function randomizeGeometry(geometry, amount) {
            const positions = geometry.attributes.position;
            
            for (let i = 0; i < positions.count; i++) {
                positions.setXYZ(
                    i,
                    positions.getX(i) + (Math.random() - 0.5) * amount,
                    positions.getY(i) + (Math.random() - 0.5) * amount,
                    positions.getZ(i) + (Math.random() - 0.5) * amount
                );
            }
            
            geometry.computeVertexNormals();
        }
        
        // Function to create a procedural dirt texture
        function createDirtTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 256;
            const context = canvas.getContext('2d');
            
            // Fill with white base
            context.fillStyle = 'rgb(255, 255, 255)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add dirt splotches and streaks
            for (let i = 0; i < 200; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 8 + 2;
                
                // Random dirt color (dark gray to brown)
                const brown = 100 + Math.random() * 55;
                const gray = brown - 20 - Math.random() * 30;
                
                context.fillStyle = `rgba(${brown}, ${gray}, ${gray * 0.7}, 0.1)`;
                
                // Random dirt shape
                if (Math.random() > 0.7) {
                    // Circular dirt splotch
                    context.beginPath();
                    context.arc(x, y, size, 0, Math.PI * 2);
                    context.fill();
                } else {
                    // Streak (simulating water/rain streaks)
                    const length = size * (Math.random() * 5 + 3);
                    context.beginPath();
                    context.moveTo(x, y);
                    context.lineTo(x, y + length);
                    context.lineWidth = size * 0.5;
                    context.strokeStyle = `rgba(${brown}, ${gray}, ${gray * 0.7}, 0.05)`;
                    context.stroke();
                }
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            
            return texture;
        }
        
        // Handle car selection
        function toggleCarMenu() {
            const menu = document.getElementById('carSelectMenu');
            const display = menu.style.display === 'none' || menu.style.display === '' ? 'block' : 'none';
            menu.style.display = display;
            
            if (display === 'block') {
                // Update specs with current values
                updateCarSelectionSpecs();
                
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    initCarSelectionModelViewers();
                }, 50);
            }
        }
        
        // Initialize 3D model viewers for car selection
        let mustangViewer, porscheViewer, revueltoViewer, huracanViewer, patrolViewer, dragsterViewer;
        let mustangModel, porscheModel, revueltoModel, huracanModel, patrolModel, dragsterModel;
        let mustangViewerActive = false;
        let porscheViewerActive = false;
        let revueltoViewerActive = false;
        let huracanViewerActive = false;
        let patrolViewerActive = false;
        let dragsterViewerActive = false;
        
        function initCarSelectionModelViewers() {
            // Only initialize if not already initialized
            if (!mustangViewerActive) {
                initMustangViewer();
            }
            
            if (!porscheViewerActive) {
                initPorscheViewer();
            }
            
            if (!revueltoViewerActive) {
                initRevueltoViewer();
            }
            
            if (!huracanViewerActive) {
                initHuracanViewer();
            }
            
            if (!patrolViewerActive) {
                initPatrolViewer();
            }
            
            if (!dragsterViewerActive) {
                initDragsterViewer();
            }
        }
        
        function initMustangViewer() {
            const container = document.getElementById('mustang-model-viewer');
            if (!container) return;
            
            // Clear container if it has children already
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Create scene, camera, renderer
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const camera = new THREE.PerspectiveCamera(42, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 4.5); // Adjusted to match the Mustang scale of 1.5
            camera.lookAt(0, 0.5, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffcc, 2.0); // Warmer light color with intensity 2.0
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0005; // Fixes shadow acne
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality
            scene.add(directionalLight);
            
            // Add platform
            const platformGeometry = new THREE.BoxGeometry(5, 0.1, 5);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.2
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -0.05;
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Create car group
            mustangModel = new THREE.Group();
            scene.add(mustangModel);
            
            // Load Mustang model
            const loader = new THREE.GLTFLoader();
            
            // Use the same paths as in the main game
            const pathsToTry = [
                'FordMustang/scene.gltf',
                './FordMustang/scene.gltf',
                '../FordMustang/scene.gltf',
                '../../FordMustang/scene.gltf',
                window.location.href.substr(0, window.location.href.lastIndexOf('/') + 1) + 'FordMustang/scene.gltf'
            ];
            
            // Try to load using multiple path options
            loadModelWithFallback(loader, pathsToTry, (gltf) => {
                const model = gltf.scene;
                
                // Apply transformations
                model.scale.set(1.5, 1.5, 1.5); // Enlarge the Mustang by 1.5x
                model.position.set(0, 0, 0);
                model.rotation.y = Math.PI; // Rotate to face forward
                
                // Add to group
                mustangModel.add(model);
                
                // Apply shadows
                model.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        
                        // Fix glass transparency for Porsche windows
                        if (node.name.includes('window') || node.name.includes('glass') || 
                            (node.material && (
                                node.material.name?.includes('window') || 
                                node.material.name?.includes('glass')
                             ))) {
                            if (node.material) {
                                node.material.transparent = true;
                                node.material.opacity = 0.0; // Completely transparent windows (no tint)
                                node.material.refractionRatio = 0.98; // Higher refraction ratio
                                node.material.envMapIntensity = 1.0; // Standard reflection intensity
                            }
                        }
                    }
                });
            });
            
            // Animation function
            function animate() {
                if (!mustangViewerActive) return;
                
                requestAnimationFrame(animate);
                
                if (mustangModel) {
                    mustangModel.rotation.y += 0.01;
                }
                
                renderer.render(scene, camera);
            }
            
            // Start animation
            mustangViewerActive = true;
            animate();
            
            // Handle window resize
            function onResize() {
                if (!container) return;
                
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            window.addEventListener('resize', onResize);
        }
        
        function initPorscheViewer() {
            const container = document.getElementById('porsche-model-viewer');
            if (!container) return;
            
            // Clear container if it has children already
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Create scene, camera, renderer
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 7); // Positioned further back to make the car appear smaller
            camera.lookAt(0, 0.5, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            renderer.physicallyCorrectLights = true; // Makes lights behave more like real world lights
            renderer.outputEncoding = THREE.sRGBEncoding; // Correct color space
            renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinema-quality tone mapping
            renderer.toneMappingExposure = 1.5; // Slightly increased for better color saturation
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); // Sky-blue tinted ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffcc, 2.0); // Warmer light color with intensity 2.0
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0005; // Fixes shadow acne
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality
            scene.add(directionalLight);
            
            // Add platform
            const platformGeometry = new THREE.BoxGeometry(5, 0.1, 5);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.2
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -0.05;
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Create car group
            porscheModel = new THREE.Group();
            scene.add(porscheModel);
            
            // Load Porsche model
            const loader = new THREE.GLTFLoader();
            
            // Use the same paths as in the main game
            const pathsToTry = [
                'Porsche911TurboS/scene.gltf',
                './Porsche911TurboS/scene.gltf',
                '../Porsche911TurboS/scene.gltf',
                '../../Porsche911TurboS/scene.gltf',
                window.location.href.substr(0, window.location.href.lastIndexOf('/') + 1) + 'Porsche911TurboS/scene.gltf'
            ];
            
            // Try to load using multiple path options
            loadModelWithFallback(loader, pathsToTry, (gltf) => {
                const model = gltf.scene;
                
                // Apply transformations
                model.scale.set(0.8, 0.8, 0.8); // Reduced size from 1 to 0.8
                model.position.set(0, 0, 0);
                model.rotation.y = Math.PI; // Rotate to face forward
                
                // Add to group
                porscheModel.add(model);
                
                // Apply shadows
                model.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        
                        // Fix glass transparency for Porsche windows
                        if (node.name.includes('window') || node.name.includes('glass') || 
                            (node.material && (
                                node.material.name?.includes('window') || 
                                node.material.name?.includes('glass')
                             ))) {
                            if (node.material) {
                                node.material.transparent = true;
                                node.material.opacity = 0.0; // Completely transparent windows (no tint)
                                node.material.refractionRatio = 0.98; // Higher refraction ratio
                                node.material.envMapIntensity = 1.0; // Standard reflection intensity
                            }
                        }
                        
                        // Mark wheel elements for animation
                        const name = node.name.toLowerCase();
                        if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) {
                            node.userData.isWheel = true;
                            // Set proper rotation axis for wheels to spin forward
                            node.userData.wheelAxis = 'x';
                        }
                    }
                });
            });
            
            // Animation function
            function animate() {
                if (!porscheViewerActive) return;
                
                requestAnimationFrame(animate);
                
                if (porscheModel) {
                    porscheModel.rotation.y += 0.01;
                }
                
                renderer.render(scene, camera);
            }
            
            // Start animation
            porscheViewerActive = true;
            animate();
            
            // Handle window resize
            function onResize() {
                if (!container) return;
                
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            window.addEventListener('resize', onResize);
        }
        
        // Helper function to try multiple paths for model loading
        function loadModelWithFallback(loader, paths, onLoad) {
            function tryNextPath(index) {
                if (index >= paths.length) {
                    console.error('Failed to load model after trying all paths');
                    return;
                }
                
                loader.load(
                    paths[index],
                    onLoad,
                    undefined,
                    (error) => {
                        console.warn(`Failed to load model from ${paths[index]}: ${error.message}`);
                        tryNextPath(index + 1);
                    }
                );
            }
            
            tryNextPath(0);
        }
        
        function selectCar(event) {
            // Check if the click is on the select button or the car option div
            let target = event.target;
            let carType;
            
            if (target.classList.contains('car-select-button')) {
                carType = target.getAttribute('data-car');
            } else if (target.classList.contains('car-option')) {
                carType = target.getAttribute('data-car');
            } else {
                // Check if the click is on a child element of car-option
                while (target && !target.classList.contains('car-option')) {
                    target = target.parentElement;
                }
                
                if (target) {
                    carType = target.getAttribute('data-car');
                }
            }
            
            if (!carType) return;
            
            // Hide the menu
            document.getElementById('carSelectMenu').style.display = 'none';
            
            // Don't do anything if the same car is selected
            if ((carType === 'mustang' && currentCarName === '2024 Ford Mustang GT') ||
                (carType === 'porsche' && currentCarName === '992 Porsche 911 Turbo S') ||
                (carType === 'revuelto' && currentCarName === 'Lamborghini Revuelto') ||
                (carType === 'huracan' && currentCarName === 'Lamborghini Huracan STO') ||
                (carType === 'patrol' && currentCarName === 'Nissan Patrol VTC')) {
                return;
            }
            
            // Update current car specs
            if (carType === 'mustang') {
                currentCarSpecs = MUSTANG_SPECS;
                currentCarName = '2024 Ford Mustang GT';
                
                // Stop other viewers to save resources
                porscheViewerActive = false;
                revueltoViewerActive = false;
                huracanViewerActive = false;
                patrolViewerActive = false;
            } else if (carType === 'porsche') {
                currentCarSpecs = PORSCHE_SPECS;
                currentCarName = '992 Porsche 911 Turbo S';
                
                // Stop other viewers to save resources
                mustangViewerActive = false;
                revueltoViewerActive = false;
                huracanViewerActive = false;
                patrolViewerActive = false;
            } else if (carType === 'revuelto') {
                currentCarSpecs = REVUELTO_SPECS;
                currentCarName = 'Lamborghini Revuelto';
                
                // Stop other viewers to save resources
                mustangViewerActive = false;
                porscheViewerActive = false;
                huracanViewerActive = false;
                patrolViewerActive = false;
            } else if (carType === 'huracan') {
                currentCarSpecs = HURACAN_SPECS;
                currentCarName = 'Lamborghini Huracan STO';
                
                // Stop other viewers to save resources
                mustangViewerActive = false;
                porscheViewerActive = false;
                revueltoViewerActive = false;
                patrolViewerActive = false;
            } else if (carType === 'patrol') {
                currentCarSpecs = PATROL_SPECS;
                currentCarName = 'Nissan Patrol VTC';
                
                // Stop other viewers to save resources
                mustangViewerActive = false;
                porscheViewerActive = false;
                revueltoViewerActive = false;
                huracanViewerActive = false;
            } else if (carType === 'dragster') {
                currentCarSpecs = DRAGSTER_SPECS;
                currentCarName = 'Top Fuel Dragster';
                
                // Stop other viewers to save resources
                mustangViewerActive = false;
                porscheViewerActive = false;
                revueltoViewerActive = false;
                huracanViewerActive = false;
                patrolViewerActive = false;
            }
            
            // Update car model display
            document.getElementById('car-model').textContent = currentCarName;
            
            // Update specs popup
            updateCarSpecsDisplay();
            
            // Recreate the car with the new model
            replaceCar();
        }
        
        function replaceCar() {
            // Remove the current car from the scene
            scene.remove(car);
            
            // Create a new car
            createCar();
            
            // Reset car position based on selected car
            if (currentCarName.includes('Porsche')) {
                car.position.set(-TRACK_WIDTH/4, -0.5, 6); // Position Porsche 1 meter further at y = -0.5
            } else {
                car.position.set(-TRACK_WIDTH/4, -0.5, 5); // Standard position for Mustang at y = -0.5
            }
            car.position.set(car.position.x, car.position.y, car.position.z);
            
            // Always start in first gear when changing cars
            currentGear = 1;
            
            // Reset RPM to idle
            rpm = currentCarSpecs.idleRPM;
            
            // Update the gear indicator display
            updateGearDisplay();
        }
        
        function updateCarSpecsDisplay() {
            // Update the car specs popup title
            const popupTitle = document.querySelector('#car-specs-popup h3');
            popupTitle.textContent = `${currentCarName} Specs`;
            
            // Update the car specs in the popup
            const specsList = document.getElementById('car-specs-list');
            
            // Clear existing specs
            specsList.innerHTML = '';
            
            // Add new specs
            const specs = [
                { label: 'Max Power', value: `${currentCarSpecs.maxPower} HP` },
                { label: 'Max Torque', value: `${currentCarSpecs.maxTorque} Nm` },
                { label: 'Redline', value: `${currentCarSpecs.redlineRPM} RPM` },
                { label: 'Weight', value: `${currentCarSpecs.weight} kg` },
                { label: 'Drivetrain', value: currentCarSpecs.drivetrain },
                { label: 'Top Speed', value: `${currentCarSpecs.maxSpeed} ${currentCarName.includes('Porsche') ? 'kph' : 'mph'}` },
                { label: 'Gears', value: `${currentCarSpecs.gearRatios.length - 1}-speed` }
            ];
            
            specs.forEach(spec => {
                const specItem = document.createElement('div');
                specItem.classList.add('spec-item');
                specItem.innerHTML = `<span class="spec-label">${spec.label}:</span> <span class="spec-value">${spec.value}</span>`;
                specsList.appendChild(specItem);
            });
            
            // Update model license info based on the current car
            const modelLicense = document.getElementById('model-license');
            
            if (currentCarName.includes('Porsche')) {
                modelLicense.innerHTML = `
                    <p><strong>Model Credit:</strong> "Porsche 911 Turbo S" by 3D Cars Studio™, licensed under CC-BY-4.0</p>
                    <p><a href="https://sketchfab.com/3d-models/porsche-911-turbo-s-081cf9a708bb4b8b8f14d55b56ffdfe9" style="color: #ff5500;">View on Sketchfab</a></p>
                `;
            } else if (currentCarName.includes('Revuelto')) {
                modelLicense.innerHTML = `
                    <p><strong>Model Credit:</strong> "Lamborghini Revuelto" by Car2022, licensed under CC-BY-4.0</p>
                    <p><a href="https://sketchfab.com/3d-models/lamborghini-revuelto-c0b31baef55142d69d320e6e22ad96dc" style="color: #ff5500;">View on Sketchfab</a></p>
                `;
            } else if (currentCarName.includes('Huracan')) {
                modelLicense.innerHTML = `
                    <p><strong>Model Credit:</strong> "2021 Lamborghini Huracán STO" by Ddiaz Design, licensed under CC-BY-4.0</p>
                    <p><a href="https://sketchfab.com/3d-models/2021-lamborghini-huracan-sto-ca6dced4db01401ab52ae4b531c167f1" style="color: #ff5500;">View on Sketchfab</a></p>
                `;
            } else if (currentCarName.includes('Patrol')) {
                modelLicense.innerHTML = `
                    <p><strong>Model Credit:</strong> "Nissan Super Safari SDC PERFORMANCE™️" by SDC PERFORMANCE™️, licensed under CC-BY-4.0</p>
                    <p><a href="https://sketchfab.com/3d-models/nissan-super-safari-sdc-performancetm-ee30651d805d4327adef9692de98472e" style="color: #ff5500;">View on Sketchfab</a></p>
                `;
            } else if (currentCarName.includes('Dragster')) {
                modelLicense.innerHTML = `
                    <p><strong>Model Credit:</strong> "Dragster." by the_86_guy, licensed under CC-BY-4.0</p>
                    <p><a href="https://sketchfab.com/3d-models/dragster-3a1db4a880c34dada780cd2aad0ac830" style="color: #ff5500;">View on Sketchfab</a></p>
                `;
            } else {
                // Default to Mustang
                modelLicense.innerHTML = `
                    <p><strong>Model Credit:</strong> "Ps1 Low-poly 2024 Ford Mustang Dark Horse" by LolAndPop, licensed under CC-BY-4.0</p>
                    <p><a href="https://sketchfab.com/3d-models/ps1-low-poly-2024-ford-mustang-dark-horse-d15e5daca29a4b7384b5743f1ec53bd1" style="color: #ff5500;">View on Sketchfab</a></p>
                `;
            }
            
            // Initialize the 3D model viewer if not already done
            if (!document.getElementById('popup-model-scene')) {
                initPopupModelViewer();
            } else {
                // Update the model if the viewer is already initialized
                updatePopupCarModel();
            }
        }
        
        function updatePopupCarModel() {
            // Clear any existing model
            while(popupModelCar && popupModelCar.children.length > 0) {
                popupModelCar.remove(popupModelCar.children[0]);
            }
            
            const gltfLoader = new THREE.GLTFLoader();
            
            // Determine which model to load based on the currently selected car
            let modelPath;
            if (currentCarName.includes('Porsche')) {
                modelPath = 'Porsche911TurboS/scene.gltf';
            } else if (currentCarName.includes('Revuelto')) {
                modelPath = 'Revuelto/scene.gltf';
            } else if (currentCarName.includes('Huracan')) {
                modelPath = 'HuracanSTO/scene.gltf';
            } else if (currentCarName.includes('Patrol')) {
                modelPath = 'NissanPatrolVTC/scene.gltf';
            } else if (currentCarName.includes('Dragster')) {
                modelPath = 'Dragster/scene.gltf';
            } else {
                modelPath = 'FordMustang/scene.gltf'; // Default to Mustang
            }
            
            // Determine appropriate scale for each car model
            let modelScale;
            if (currentCarName.includes('Porsche')) {
                modelScale = 0.5;
            } else if (currentCarName.includes('Revuelto')) {
                modelScale = 2700; // Increased from 900 to 2700 (3x larger)
            } else if (currentCarName.includes('Huracan')) {
                modelScale = 2700; // Increased from 900 to 2700 (3x larger)
            } else if (currentCarName.includes('Patrol')) {
                modelScale = 1.7;
            } else if (currentCarName.includes('Dragster')) {
                modelScale = 0.05; // Set scale to exactly 0.05 as requested
            } else {
                modelScale = 1.2; // Default for Mustang
            }
            
            console.debug(`Loading ${currentCarName} model for popup (path: ${modelPath}, scale: ${modelScale})...`);
            
            gltfLoader.load(modelPath, (gltf) => {
                console.debug('Popup model loaded successfully');
                
                // Set up the model
                const carModel = gltf.scene;
                carModel.scale.set(modelScale, modelScale, modelScale);
                
                // Specific rotation for each car model to ensure proper orientation
                if (currentCarName.includes('Porsche')) {
                    carModel.rotation.y = Math.PI;
                } else if (currentCarName.includes('Revuelto')) {
                    carModel.rotation.y = Math.PI;
                } else if (currentCarName.includes('Huracan')) {
                    carModel.rotation.y = Math.PI;
                } else if (currentCarName.includes('Patrol')) {
                    carModel.rotation.y = Math.PI / 2; // Rotating 90 degrees
                } else if (currentCarName.includes('Dragster')) {
                    carModel.rotation.y = Math.PI / 4; // Rotating 45 degrees for better view
                } else {
                    carModel.rotation.y = Math.PI; // Default for Mustang
                }
                
                // Add glass transparency fix for Porsche
                if (currentCarName.includes('Porsche')) {
                    carModel.traverse((node) => {
                        if (node.isMesh && 
                            (node.name.includes('window') || node.name.includes('glass') || 
                             (node.material && (
                                 node.material.name?.includes('window') || 
                                 node.material.name?.includes('glass')
                             )))) {
                            if (node.material) {
                                node.material.transparent = true;
                                node.material.opacity = 0.0; // Completely transparent windows (no tint)
                                node.material.refractionRatio = 0.98; // Higher refraction ratio
                                node.material.envMapIntensity = 1.0; // Standard reflection intensity
                            }
                        }
                    });
                }
                
                // Add to car container
                popupModelCar.add(carModel);
                
                // Adjust camera position based on car size
                if (currentCarName.includes('Patrol')) {
                    // Move camera back for larger vehicles
                    popupModelCamera.position.set(0, 1.5, 6);
                } else if (currentCarName.includes('Huracan') || currentCarName.includes('Revuelto')) {
                    // Adjust for Lamborghini models with scale of 2700
                    popupModelCamera.position.set(0, 45, 120);
                } else if (currentCarName.includes('Dragster')) {
                    // Adjust for the long dragster
                    popupModelCamera.position.set(0, 1.2, 7);
                } else {
                    // Default camera position
                    popupModelCamera.position.set(0, 1, 4);
                }
                popupModelCamera.lookAt(0, 0, 0);
                
                // Start animation loop
                animatePopupModel();
            }, undefined, (error) => {
                console.error(`Error loading popup model (${modelPath}):`, error);
                // Create a simple car model as fallback
                createSimpleModelForPopup();
            });
        }
        
        // Initial position the car starts from in 3D space
        initialPosition = car.position.z;
        lightSequenceActive = false;
        
        // Update car menu position to match viewport height
        function updateCarMenuPosition() {
            const carSelectButton = document.getElementById('carSelectButton');
            carSelectButton.style.top = '50%';
            carSelectButton.style.transform = 'translateY(-50%)';
        }
        
        // Call immediately and on window resize
        updateCarMenuPosition();
        window.addEventListener('resize', updateCarMenuPosition);
        
        // Add event listeners after document is ready
        document.addEventListener('DOMContentLoaded', function() {
            // Existing car selection setup
            document.getElementById('carSelectButton').addEventListener('click', toggleCarMenu);
            
            // Add event listener for close button
            document.getElementById('closeCarSelect').addEventListener('click', function() {
                document.getElementById('carSelectMenu').style.display = 'none';
                
                // Stop model viewers to save resources
                mustangViewerActive = false;
                porscheViewerActive = false;
            });
            
            // Add event listeners for car selection
            const carOptions = document.querySelectorAll('.car-option');
            carOptions.forEach(option => {
                option.addEventListener('click', selectCar);
            });
            
            // Add event listeners for select buttons 
            const selectButtons = document.querySelectorAll('.car-select-button');
            selectButtons.forEach(button => {
                button.addEventListener('click', selectCar);
            });
        });
        
        // Add a function to update the car selection menu with dynamic specs
        function updateCarSelectionSpecs() {
            // Update Mustang specs
            const mustangSpecs = document.querySelector('.car-option[data-car="mustang"] .car-specs-grid');
            if (mustangSpecs) {
                mustangSpecs.innerHTML = `
                    <div class="car-spec-item">
                        <span class="car-spec-label">Power</span>
                        <span class="car-spec-value">${MUSTANG_SPECS.maxPower}</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Torque</span>
                        <span class="car-spec-value">${MUSTANG_SPECS.maxTorque}</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Redline</span>
                        <span class="car-spec-value">${MUSTANG_SPECS.redlineRPM} RPM</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Top Speed</span>
                        <span class="car-spec-value">${MUSTANG_SPECS.maxSpeed} mph</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Weight</span>
                        <span class="car-spec-value">${MUSTANG_SPECS.weight} kg</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Drivetrain</span>
                        <span class="car-spec-value">${MUSTANG_SPECS.drivetrain}</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Transmission</span>
                        <span class="car-spec-value">10-Speed AT</span>
                    </div>
                `;
            }
            
            // Update Porsche specs
            const porscheSpecs = document.querySelector('.car-option[data-car="porsche"] .car-specs-grid');
            if (porscheSpecs) {
                porscheSpecs.innerHTML = `
                    <div class="car-spec-item">
                        <span class="car-spec-label">Power</span>
                        <span class="car-spec-value">${PORSCHE_SPECS.maxPower}</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Torque</span>
                        <span class="car-spec-value">${PORSCHE_SPECS.maxTorque}</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Redline</span>
                        <span class="car-spec-value">${PORSCHE_SPECS.redlineRPM} RPM</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Top Speed</span>
                        <span class="car-spec-value">${PORSCHE_SPECS.maxSpeed} kph</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Weight</span>
                        <span class="car-spec-value">${PORSCHE_SPECS.weight} kg</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Drivetrain</span>
                        <span class="car-spec-value">${PORSCHE_SPECS.drivetrain}</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Transmission</span>
                        <span class="car-spec-value">8-Speed PDK</span>
                    </div>
                `;
            }
            
            // Update Dragster specs
            const dragsterSpecs = document.querySelector('.car-option[data-car="dragster"] .car-specs-grid');
            if (dragsterSpecs) {
                dragsterSpecs.innerHTML = `
                    <div class="car-spec-item">
                        <span class="car-spec-label">Power</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.maxPower} HP</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Torque</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.maxTorque} Nm</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">0-60 mph</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.zeroToSixty} sec</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">1/4 Mile</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.quarterMileTime} sec</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Top Speed</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.maxSpeed} kph</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Weight</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.weight} kg</span>
                    </div>
                    <div class="car-spec-item">
                        <span class="car-spec-label">Drivetrain</span>
                        <span class="car-spec-value">${DRAGSTER_SPECS.drivetrain}</span>
                    </div>
                `;
            }
        }
        
        // Call updateCarSelectionSpecs on toggle menu
        function toggleCarMenu() {
            const menu = document.getElementById('carSelectMenu');
            const display = menu.style.display === 'none' || menu.style.display === '' ? 'block' : 'none';
            menu.style.display = display;
            
            if (display === 'block') {
                // Update specs with current values
                updateCarSelectionSpecs();
                
                // Small delay to ensure DOM is ready
                setTimeout(() => {
                    initCarSelectionModelViewers();
                }, 50);
            }
        }

        function initRevueltoViewer() {
            const container = document.getElementById('revuelto-model-viewer');
            if (!container) return;
            
            // Clear container if it has children already
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Create scene, camera, renderer
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 5);
            camera.lookAt(0, 0.5, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x89bbff, 0.8); // Sky-blue tinted ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Pure white directional light
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0005; // Fixes shadow acne
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality
            scene.add(directionalLight);
            
            // Add platform
            const platformGeometry = new THREE.BoxGeometry(5, 0.1, 5);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.1,
                envMapIntensity: 1.5
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -0.75;
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Create a group to hold the model
            revueltoModel = new THREE.Group();
            scene.add(revueltoModel);
            
            // Create loader for the GLTF model
            const loader = new THREE.GLTFLoader();
            
            // Try multiple paths to load the model
            const pathsToTry = [
                'Revuelto/scene.gltf',
                './Revuelto/scene.gltf',
                '../Revuelto/scene.gltf',
                '../../Revuelto/scene.gltf',
                window.location.href.substr(0, window.location.href.lastIndexOf('/') + 1) + 'Revuelto/scene.gltf'
            ];
            
            // Try to load using multiple path options
            loadModelWithFallback(loader, pathsToTry, (gltf) => {
                const model = gltf.scene;
                
                // Apply transformations
                model.scale.set(120, 120, 120); // Changed from 80 to 120
                model.position.set(0, 0, 0);
                model.rotation.y = Math.PI; // Rotate to face forward
                
                // Add to group
                revueltoModel.add(model);
                
                // Apply shadows and fix glass transparency
                model.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        
                        // Fix glass transparency for windows
                        if (node.name.includes('window') || node.name.includes('glass') || 
                            (node.material && (
                                node.material.name?.includes('window') || 
                                node.material.name?.includes('glass')
                            ))) {
                            if (node.material) {
                                node.material.transparent = true;
                                node.material.opacity = 0.0; // Completely transparent windows (no tint)
                                node.material.refractionRatio = 0.98; // Higher refraction ratio
                                node.material.envMapIntensity = 1.0; // Standard reflection intensity
                            }
                        }
                        
                        // Mark wheel elements for animation
                        const name = node.name.toLowerCase();
                        if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) {
                            node.userData.isWheel = true;
                            // Default rotation axis for wheels
                            node.userData.wheelAxis = 'z';
                        }
                    }
                });
            });
            
            // Animation function
            function animate() {
                if (!revueltoViewerActive) return;
                
                requestAnimationFrame(animate);
                
                if (revueltoModel) {
                    revueltoModel.rotation.y += 0.01;
                }
                
                renderer.render(scene, camera);
            }
            
            // Start animation
            revueltoViewerActive = true;
            animate();
            
            // Handle window resize
            function onResize() {
                if (!container) return;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            window.addEventListener('resize', onResize);
            
            // Create the viewer object for reference
            revueltoViewer = {
                scene: scene,
                camera: camera,
                renderer: renderer,
                container: container
            };
        }

        function initHuracanViewer() {
            const container = document.getElementById('huracan-model-viewer');
            if (!container) return;
            
            // Clear container if it has children already
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Create scene, camera, renderer
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 5);
            camera.lookAt(0, 0.5, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x89bbff, 0.8); // Sky-blue tinted ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Pure white directional light
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0005; // Fixes shadow acne
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality
            scene.add(directionalLight);
            
            // Add platform
            const platformGeometry = new THREE.BoxGeometry(5, 0.1, 5);
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.1,
                envMapIntensity: 1.5
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -0.55; // Lowered platform to match car at y=0.5
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Create a group to hold the model
            huracanModel = new THREE.Group();
            scene.add(huracanModel);
            
            // Create loader for the GLTF model
            const loader = new THREE.GLTFLoader();
            
            // Try multiple paths to load the model
            const pathsToTry = [
                'HuracanSTO/scene.gltf',
                './HuracanSTO/scene.gltf',
                '../HuracanSTO/scene.gltf',
                '../../HuracanSTO/scene.gltf',
                window.location.href.substr(0, window.location.href.lastIndexOf('/') + 1) + 'HuracanSTO/scene.gltf'
            ];
            
            // Try to load using multiple path options
            loadModelWithFallback(loader, pathsToTry, (gltf) => {
                const model = gltf.scene;
                
                // Apply transformations
                model.scale.set(120, 120, 120); // Changed from 160 to 120
                model.position.set(0, 0, 0); // Changed from 0.1 to 0 as requested
                model.rotation.y = 0; // Changed to 0 instead of Math.PI to face forward correctly
                
                // Add to group
                huracanModel.add(model);
                
                // Apply shadows and fix glass transparency
                model.traverse((node) => {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                        
                        // Fix glass transparency for windows
                        if (node.name.includes('window') || node.name.includes('glass') || 
                            (node.material && (
                                node.material.name?.includes('window') || 
                                node.material.name?.includes('glass')
                            ))) {
                            if (node.material) {
                                node.material.transparent = true;
                                node.material.opacity = 0.0; // Completely transparent windows (no tint)
                                node.material.refractionRatio = 0.98; // Higher refraction ratio
                                node.material.envMapIntensity = 1.0; // Standard reflection intensity
                            }
                        }
                        
                        // Mark wheel elements for animation
                        const name = node.name.toLowerCase();
                        if (name.includes('wheel') || name.includes('tire') || name.includes('rim')) {
                            node.userData.isWheel = true;
                            // Default rotation axis for wheels
                            node.userData.wheelAxis = 'x'; // Changed from 'z' to 'x' for forward rotation
                        }
                    }
                });
            });
            
            // Animation function
            function animate() {
                if (!huracanViewerActive) return;
                
                requestAnimationFrame(animate);
                
                if (huracanModel) {
                    huracanModel.rotation.y += 0.01;
                }
                
                renderer.render(scene, camera);
            }
            
            // Start animation
            huracanViewerActive = true;
            animate();
            
            // Handle window resize
            function onResize() {
                if (!container) return;
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
            
            window.addEventListener('resize', onResize);
            
            // Create the viewer object for reference
            huracanViewer = {
                scene: scene,
                camera: camera,
                renderer: renderer,
                container: container
            };
        }

        function initPatrolViewer() {
            const container = document.getElementById('patrol-model-viewer');
            if (!container) return;
            
            // Clear container if it has children already
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Create scene, camera, renderer
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 8); // Positioned further back to make the SUV appear smaller
            camera.lookAt(0, 0.8, 0); // Looking a bit higher for the taller vehicle
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x89bbff, 0.8); // Sky-blue tinted ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Pure white directional light
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0005; // Fixes shadow acne
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality
            scene.add(directionalLight);
            
            // Add platform
            const platformGeometry = new THREE.BoxGeometry(6, 0.1, 6); // Larger platform for the SUV
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x444444,
                metalness: 0.8,
                roughness: 0.2
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Load the Nissan Patrol model
            const gltfLoader = new THREE.GLTFLoader();
            
            // Set up loading for the model
            gltfLoader.load('NissanPatrolVTC/scene.gltf', (gltf) => {
                // Get the model from loaded data
                patrolModel = gltf.scene;
                
                // Scale and position the model
                patrolModel.scale.set(1.7, 1.7, 1.7); // Appropriate scale for this model
                patrolModel.position.y = 0; // Center it on the platform
                
                // Apply rotation for best view angle
                patrolModel.rotation.y = Math.PI / 2; // Rotate 90 degrees for best view
                
                // Add to scene
                scene.add(patrolModel);
                
                // Setup animation loop
                animate();
                
                // Update flag
                patrolViewerActive = true;
            });
            
            // Animation function
            function animate() {
                if (!patrolViewerActive) return;
                
                requestAnimationFrame(animate);
                
                // Slowly rotate the model
                if (patrolModel) {
                    patrolModel.rotation.y += 0.01; // Slow rotation
                }
                
                // Render scene
                renderer.render(scene, camera);
            }
        }
        
        function initDragsterViewer() {
            const container = document.getElementById('dragster-model-viewer');
            if (!container) return;
            
            // Clear container if it has children already
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            
            // Create scene, camera, renderer
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 1.2, 7); // Positioned to see the long dragster
            camera.lookAt(0, 0.5, 0);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Adds soft edges to shadows
            renderer.shadowMap.autoUpdate = true;
            renderer.shadowMap.needsUpdate = true;
            container.appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x89bbff, 0.8); // Sky-blue tinted ambient light
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0); // Pure white directional light
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.mapSize.height = 4096; // Doubled shadow map resolution for more detailed shadows
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 20;
            directionalLight.shadow.camera.left = -10;
            directionalLight.shadow.camera.right = 10;
            directionalLight.shadow.camera.top = 10;
            directionalLight.shadow.camera.bottom = -10;
            directionalLight.shadow.bias = -0.0005; // Fixes shadow acne
            directionalLight.shadow.normalBias = 0.02; // Improves shadow quality
            scene.add(directionalLight);
            
            // Add platform
            const platformGeometry = new THREE.BoxGeometry(6, 0.1, 12); // Longer platform for the dragster
            const platformMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.8,
                roughness: 0.2
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.receiveShadow = true;
            scene.add(platform);
            
            // Load the Top Fuel Dragster model
            const gltfLoader = new THREE.GLTFLoader();
            
            // Set up loading for the model
            gltfLoader.load('Dragster/scene.gltf', (gltf) => {
                // Get the model from loaded data
                dragsterModel = gltf.scene;
                
                console.warn('DRAGSTER MODEL VIEWER - Model loaded successfully!');
                
                // Scale and position the model
                dragsterModel.scale.set(0.3, 0.3, 0.3); // Increased scale for better visibility
                dragsterModel.position.y = 0.2; // Slight lift from platform
                
                // Apply rotation for best view angle
                dragsterModel.rotation.y = Math.PI / 4; // Rotate 45 degrees for better view
                
                // Add to scene
                scene.add(dragsterModel);
                
                /* Remove debug sphere
                // Add a debug sphere to show where the model should be
                const debugSphere = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true })
                );
                debugSphere.position.set(0, 0.5, 0);
                scene.add(debugSphere);
                */
                
                // Setup animation loop
            animate();
            
                // Update flag
                dragsterViewerActive = true;
            });
            
            // Animation function
            function animate() {
                if (!dragsterViewerActive) return;
                
                requestAnimationFrame(animate);
                
                // Slowly rotate the model
                if (dragsterModel) {
                    dragsterModel.rotation.y += 0.01; // Slow rotation
                }
                
                // Render scene
                renderer.render(scene, camera);
            }
        }
    </script>
    
    <!-- Settings Functionality -->
    <script>
        // Settings functionality
        let currentShadowResolution = 4096; // Default shadow resolution
        
        // Wait for document to be ready
        window.addEventListener('load', function() {
            console.log("Settings initialization started");
            
            // Set up settings button and popup
            const settingsButton = document.getElementById('settings-button');
            const settingsPopup = document.getElementById('settings-popup');
            const closeSettings = document.querySelector('.close-settings');
            const applySettings = document.getElementById('apply-settings');
            const shadowQuality = document.getElementById('shadow-quality');
            
            // Set up feedback button redirect
            const feedbackButton = document.getElementById('feedback-button');
            feedbackButton.addEventListener('click', function() {
                window.location.href = "https://dragsim.featurebase.app/en";
            });
            
            // Ensure the shadow quality dropdown matches the current resolution
            if (directionalLight && directionalLight.shadow && directionalLight.shadow.mapSize) {
                const currentRes = directionalLight.shadow.mapSize.width;
                console.log("Current shadow resolution detected:", currentRes);
                currentShadowResolution = currentRes;
                
                // Set the dropdown to match the current resolution
                for(let i = 0; i < shadowQuality.options.length; i++) {
                    if (parseInt(shadowQuality.options[i].value) === currentRes) {
                        shadowQuality.selectedIndex = i;
                        break;
                    }
                }
            } else {
                console.log("No directional light shadow detected, using default resolution:", currentShadowResolution);
            }
            
            // Show settings popup when settings button is clicked
            settingsButton.addEventListener('click', function() {
                settingsPopup.style.display = 'block';
            });
            
            // Hide settings popup when close button is clicked
            closeSettings.addEventListener('click', function() {
                settingsPopup.style.display = 'none';
            });
            
            // Apply settings immediately when shadow quality changes
            shadowQuality.addEventListener('change', function() {
                const newResolution = parseInt(shadowQuality.value);
                if (newResolution !== currentShadowResolution) {
                    updateShadowResolution(newResolution);
                    currentShadowResolution = newResolution;
                    // Add visual feedback
                    applySettings.textContent = "Applied!";
                    setTimeout(() => {
                        applySettings.textContent = "Apply Changes";
                    }, 1000);
                }
            });
            
            // Apply settings when apply button is clicked
            applySettings.addEventListener('click', function() {
                const newResolution = parseInt(shadowQuality.value);
                if (newResolution !== currentShadowResolution) {
                    updateShadowResolution(newResolution);
                    currentShadowResolution = newResolution;
                }
                settingsPopup.style.display = 'none';
            });
            
            // Close settings when clicking outside the popup
            window.addEventListener('click', function(event) {
                if (event.target === settingsPopup) {
                    settingsPopup.style.display = 'none';
                }
            });
        });
        
        // Function to update shadow resolution on all directional lights
        function updateShadowResolution(resolution) {
            console.log(`Updating shadow resolution to ${resolution}px`);
            
            // Update main scene directional light
            if (directionalLight) {
                directionalLight.shadow.mapSize.width = resolution;
                directionalLight.shadow.mapSize.height = resolution;
                directionalLight.shadow.map = null; // Force shadow map recreation
            }
            
            // Update car model viewer directional lights
            try {
                // Try to find and update any directional lights in all scenes
                // Mustang viewer
                document.querySelectorAll('canvas').forEach(canvas => {
                    // Get the renderer associated with this canvas
                    const rendererContext = canvas.__webglRenderer || 
                                           canvas.__renderer || 
                                           canvas.parentElement.__renderer;
                    
                    if (rendererContext && rendererContext.shadowMap) {
                        rendererContext.shadowMap.needsUpdate = true;
                    }
                });
                
                // Update popup model scene directional lights if they exist
                if (typeof popupModelScene !== 'undefined' && popupModelScene) {
                    popupModelScene.traverse(function(node) {
                        if (node instanceof THREE.DirectionalLight && node.castShadow) {
                            node.shadow.mapSize.width = resolution;
                            node.shadow.mapSize.height = resolution;
                            node.shadow.map = null; // Force shadow map recreation
                        }
                    });
                }
                
                // Force shadow map update in all renderers
                if (renderer) {
                    renderer.shadowMap.needsUpdate = true;
                }
                
                if (typeof popupModelRenderer !== 'undefined' && popupModelRenderer) {
                    popupModelRenderer.shadowMap.needsUpdate = true;
                }
                
                // Update all directional lights across all scenes
                scene.traverse(function(node) {
                    if (node instanceof THREE.DirectionalLight && node.castShadow) {
                        node.shadow.mapSize.width = resolution;
                        node.shadow.mapSize.height = resolution;
                        node.shadow.map = null;
                    }
                });
                
            } catch(e) {
                console.error("Error updating shadow resolution:", e);
            }
            
            console.log("Shadow resolution updated successfully");
        }

        // Function to check if assets exist and are accessible
        function checkAssetsExist() {
            const assetPaths = [
                './assets/Curly_palm/scene.gltf',
                './assets/Date_palm/scene.gltf'
            ];
            
            console.debug("Checking if palm tree assets are accessible...");
            
            assetPaths.forEach(path => {
                fetch(path, { method: 'HEAD' })
                    .then(response => {
                        if (response.ok) {
                            console.debug(`✅ Asset accessible: ${path}`);
                        } else {
                            console.error(`❌ Asset not accessible: ${path} (${response.status})`);
                        }
                    })
                    .catch(error => {
                        console.error(`❌ Error accessing asset: ${path}`, error);
                    });
            });
            
            // Also check textures for one of the models
            fetch('./assets/Curly_palm/textures/Tree_0Mat_baseColor.png', { method: 'HEAD' })
                .then(response => {
                    if (response.ok) {
                        console.debug(`✅ Texture accessible: Curly_palm texture`);
                    } else {
                        console.error(`❌ Texture not accessible: Curly_palm texture (${response.status})`);
                    }
                })
                .catch(error => {
                    console.error(`❌ Error accessing texture:`, error);
                });
        }
        
        // Run the asset check when the page loads
        window.addEventListener('load', function() {
            // Check if assets exist after a short delay to ensure everything is loaded
            setTimeout(checkAssetsExist, 1000);
        });
    </script>
</body>
</html> 